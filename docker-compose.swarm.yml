version: '3.8'

# =====================================================
# Docker Swarm Stack Configuration
# Production-ready with HA, scaling, and secrets
# =====================================================

services:
  # =====================================================
  # SQL Server - Stateful Service (Single Instance)
  # =====================================================
  sqlserver:
    image: mcr.microsoft.com/mssql/server:2022-latest
    environment:
      - ACCEPT_EULA=Y
      - SA_PASSWORD_FILE=/run/secrets/sa_password
      - MSSQL_PID=Standard
    secrets:
      - sa_password
    volumes:
      - sqlserver_data:/var/opt/mssql
    networks:
      - backend
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
      resources:
        limits:
          cpus: '2'
          memory: 4G
        reservations:
          cpus: '1'
          memory: 2G
    healthcheck:
      test: /opt/mssql-tools/bin/sqlcmd -S localhost -U sa -P $$(cat /run/secrets/sa_password) -Q "SELECT 1" || exit 1
      interval: 30s
      timeout: 5s
      retries: 5
      start_period: 60s

  # =====================================================
  # Redis - Stateful Cache (Single Instance)
  # =====================================================
  redis:
    image: redis:7-alpine
    command: >
      sh -c "redis-server 
      --appendonly yes 
      --requirepass $$(cat /run/secrets/redis_password)
      --maxmemory 512mb
      --maxmemory-policy allkeys-lru"
    secrets:
      - redis_password
    volumes:
      - redis_data:/data
    networks:
      - backend
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      restart_policy:
        condition: on-failure
        delay: 5s
      resources:
        limits:
          cpus: '1'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 512M
    healthcheck:
      test: ["CMD", "redis-cli", "--raw", "incr", "ping"]
      interval: 20s
      timeout: 3s
      retries: 5

  # =====================================================
  # ASP.NET Core API - Stateless (Scalable)
  # =====================================================
  api:
    image: servermonitoring-api:latest
    environment:
      - ASPNETCORE_ENVIRONMENT=Production
      - ASPNETCORE_URLS=http://+:8080
      - ConnectionStrings__DefaultConnection=Server=sqlserver,1433;Database=ServerMonitoringDb;User Id=sa;Password_File=/run/secrets/sa_password;TrustServerCertificate=true;MultipleActiveResultSets=true
      - ConnectionStrings__RedisConnection=redis:6379,password_file=/run/secrets/redis_password,abortConnect=false,connectTimeout=5000,syncTimeout=5000
      - CacheSettings__UseRedis=true
      - JwtSettings__SecretKey_File=/run/secrets/jwt_secret
      - JwtSettings__Issuer=ServerMonitoringAPI
      - JwtSettings__Audience=ServerMonitoringClient
    secrets:
      - sa_password
      - redis_password
      - jwt_secret
    networks:
      - backend
      - frontend
    depends_on:
      - sqlserver
      - redis
    deploy:
      mode: replicated
      replicas: 3  # Start with 3 instances
      update_config:
        parallelism: 1
        delay: 10s
        failure_action: rollback
        monitor: 60s
        order: start-first
      rollback_config:
        parallelism: 1
        delay: 5s
        failure_action: pause
        monitor: 30s
        order: stop-first
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
        window: 120s
      resources:
        limits:
          cpus: '1'
          memory: 1G
        reservations:
          cpus: '0.25'
          memory: 256M
      labels:
        - "traefik.enable=true"
        - "traefik.http.routers.api.rule=PathPrefix(`/api`) || PathPrefix(`/hubs`) || PathPrefix(`/health`) || PathPrefix(`/swagger`)"
        - "traefik.http.services.api.loadbalancer.server.port=8080"
        - "traefik.http.services.api.loadbalancer.sticky.cookie=true"
        - "traefik.http.services.api.loadbalancer.healthcheck.path=/health/live"
        - "traefik.http.services.api.loadbalancer.healthcheck.interval=10s"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health/live"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 60s

  # =====================================================
  # React Frontend - Stateless (Scalable)
  # =====================================================
  web:
    image: servermonitoring-web:latest
    networks:
      - frontend
    depends_on:
      - api
    deploy:
      mode: replicated
      replicas: 2  # Start with 2 instances
      update_config:
        parallelism: 1
        delay: 10s
        failure_action: rollback
        order: start-first
      restart_policy:
        condition: on-failure
        delay: 5s
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
        reservations:
          cpus: '0.1'
          memory: 128M
      labels:
        - "traefik.enable=true"
        - "traefik.http.routers.web.rule=PathPrefix(`/`)"
        - "traefik.http.routers.web.priority=1"
        - "traefik.http.services.web.loadbalancer.server.port=3000"
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000"]
      interval: 30s
      timeout: 3s
      retries: 3

  # =====================================================
  # Traefik - Reverse Proxy & Load Balancer
  # =====================================================
  traefik:
    image: traefik:v2.11
    command:
      - "--api.dashboard=true"
      - "--providers.docker=true"
      - "--providers.docker.swarmMode=true"
      - "--providers.docker.exposedbydefault=false"
      - "--entrypoints.web.address=:80"
      - "--entrypoints.websecure.address=:443"
      - "--metrics.prometheus=true"
      - "--accesslog=true"
      - "--log.level=INFO"
    ports:
      - target: 80
        published: 80
        mode: host
      - target: 443
        published: 443
        mode: host
      - target: 8080
        published: 8080
        mode: host
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    networks:
      - frontend
    deploy:
      mode: global
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
        reservations:
          cpus: '0.1'
          memory: 128M

  # =====================================================
  # Prometheus - Metrics Collection (Optional)
  # =====================================================
  prometheus:
    image: prom/prometheus:latest
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--storage.tsdb.retention.time=30d'
    volumes:
      - prometheus_data:/prometheus
      - ./prometheus.yml:/etc/prometheus/prometheus.yml:ro
    networks:
      - backend
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: '1'
          memory: 1G

  # =====================================================
  # Grafana - Monitoring Dashboard (Optional)
  # =====================================================
  grafana:
    image: grafana/grafana:latest
    environment:
      - GF_SECURITY_ADMIN_PASSWORD__FILE=/run/secrets/grafana_password
      - GF_INSTALL_PLUGINS=grafana-clock-panel
    secrets:
      - grafana_password
    volumes:
      - grafana_data:/var/lib/grafana
    networks:
      - backend
      - frontend
    ports:
      - "3001:3000"
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: '0.5'
          memory: 512M

# =====================================================
# Networks
# =====================================================
networks:
  frontend:
    driver: overlay
    attachable: true
  backend:
    driver: overlay
    internal: true

# =====================================================
# Volumes
# =====================================================
volumes:
  sqlserver_data:
    driver: local
  redis_data:
    driver: local
  prometheus_data:
    driver: local
  grafana_data:
    driver: local

# =====================================================
# Secrets (Use: echo "password" | docker secret create secret_name -)
# =====================================================
secrets:
  sa_password:
    external: true
  redis_password:
    external: true
  jwt_secret:
    external: true
  grafana_password:
    external: true
