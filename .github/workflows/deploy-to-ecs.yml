name: Deploy to AWS ECS

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  ECR_API_REPOSITORY: servermonitoring-api
  ECR_WEB_REPOSITORY: servermonitoring-web
  ECS_CLUSTER: servermonitoring-cluster
  ECS_API_SERVICE: servermonitoring-api-service
  ECS_WEB_SERVICE: servermonitoring-web-service
  API_CONTAINER_NAME: api
  WEB_CONTAINER_NAME: web

jobs:
  deploy:
    name: Deploy to ECS
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1

    - name: Create ECR repositories if they don't exist
      run: |
        # Create API repository
        aws ecr describe-repositories --repository-names ${{ env.ECR_API_REPOSITORY }} 2>/dev/null || \
          aws ecr create-repository --repository-name ${{ env.ECR_API_REPOSITORY }}
        
        # Create Web repository
        aws ecr describe-repositories --repository-names ${{ env.ECR_WEB_REPOSITORY }} 2>/dev/null || \
          aws ecr create-repository --repository-name ${{ env.ECR_WEB_REPOSITORY }}

    - name: Build, tag, and push API image to Amazon ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        docker build -t $ECR_REGISTRY/$ECR_API_REPOSITORY:$IMAGE_TAG -f src/Presentation/ServerMonitoring.API/Dockerfile .
        docker tag $ECR_REGISTRY/$ECR_API_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_API_REPOSITORY:latest
        docker push $ECR_REGISTRY/$ECR_API_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_API_REPOSITORY:latest
        echo "API_IMAGE=$ECR_REGISTRY/$ECR_API_REPOSITORY:$IMAGE_TAG" >> $GITHUB_ENV

    - name: Build, tag, and push Web image to Amazon ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        docker build -t $ECR_REGISTRY/$ECR_WEB_REPOSITORY:$IMAGE_TAG -f ServerMonitoring.Web/Dockerfile ServerMonitoring.Web
        docker tag $ECR_REGISTRY/$ECR_WEB_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_WEB_REPOSITORY:latest
        docker push $ECR_REGISTRY/$ECR_WEB_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_WEB_REPOSITORY:latest
        echo "WEB_IMAGE=$ECR_REGISTRY/$ECR_WEB_REPOSITORY:$IMAGE_TAG" >> $GITHUB_ENV

    - name: Create IAM roles for ECS
      run: |
        # Create ECS Task Execution Role
        EXEC_ROLE_EXISTS=$(aws iam get-role --role-name ecsTaskExecutionRole-ServerMonitoring --query 'Role.RoleName' --output text 2>/dev/null || echo "None")
        
        if [ "$EXEC_ROLE_EXISTS" = "None" ]; then
          echo "Creating ecsTaskExecutionRole-ServerMonitoring..."
          
          cat > trust-policy.json <<EOF
        {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "Service": "ecs-tasks.amazonaws.com"
              },
              "Action": "sts:AssumeRole"
            }
          ]
        }
        EOF
          
          aws iam create-role \
            --role-name ecsTaskExecutionRole-ServerMonitoring \
            --assume-role-policy-document file://trust-policy.json
          
          aws iam attach-role-policy \
            --role-name ecsTaskExecutionRole-ServerMonitoring \
            --policy-arn arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
          
          echo "Waiting for role to be available..."
          sleep 10
        else
          echo "ecsTaskExecutionRole-ServerMonitoring already exists"
        fi
        
        # Create ECS Task Role
        TASK_ROLE_EXISTS=$(aws iam get-role --role-name ecsTaskRole-ServerMonitoring --query 'Role.RoleName' --output text 2>/dev/null || echo "None")
        
        if [ "$TASK_ROLE_EXISTS" = "None" ]; then
          echo "Creating ecsTaskRole-ServerMonitoring..."
          
          aws iam create-role \
            --role-name ecsTaskRole-ServerMonitoring \
            --assume-role-policy-document file://trust-policy.json
          
          echo "Waiting for role to be available..."
          sleep 10
        else
          echo "ecsTaskRole-ServerMonitoring already exists"
        fi

    - name: Create/Update secrets in AWS Secrets Manager
      run: |
        # Create JWT secret if it doesn't exist
        JWT_SECRET=$(openssl rand -base64 32)
        aws secretsmanager create-secret \
          --name servermonitoring/JWT_SECRET_KEY \
          --secret-string "$JWT_SECRET" 2>/dev/null || \
          echo "JWT secret already exists"
        
        # Create DB password
        DB_PASSWORD=$(openssl rand -base64 16)
        aws secretsmanager create-secret \
          --name servermonitoring/DB_SA_PASSWORD \
          --secret-string "$DB_PASSWORD" 2>/dev/null || \
          echo "DB password already exists"
        
        # Create Redis password
        REDIS_PASSWORD=$(openssl rand -base64 16)
        aws secretsmanager create-secret \
          --name servermonitoring/REDIS_PASSWORD \
          --secret-string "$REDIS_PASSWORD" 2>/dev/null || \
          echo "Redis password already exists"
        
        # Give execution role permission to read secrets
        POLICY_EXISTS=$(aws iam list-attached-role-policies \
          --role-name ecsTaskExecutionRole-ServerMonitoring \
          --query "AttachedPolicies[?PolicyArn=='arn:aws:iam::aws:policy/SecretsManagerReadWrite'].PolicyArn" \
          --output text)
        
        if [ -z "$POLICY_EXISTS" ]; then
          aws iam attach-role-policy \
            --role-name ecsTaskExecutionRole-ServerMonitoring \
            --policy-arn arn:aws:iam::aws:policy/SecretsManagerReadWrite
        fi

    - name: Create API task definition
      run: |
        cat > api-task-definition.json <<EOF
        {
          "family": "servermonitoring-api",
          "networkMode": "awsvpc",
          "requiresCompatibilities": ["FARGATE"],
          "cpu": "512",
          "memory": "1024",
          "executionRoleArn": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/ecsTaskExecutionRole-ServerMonitoring",
          "taskRoleArn": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/ecsTaskRole-ServerMonitoring",
          "containerDefinitions": [
            {
              "name": "${{ env.API_CONTAINER_NAME }}",
              "image": "${{ env.API_IMAGE }}",
              "cpu": 512,
              "memory": 1024,
              "essential": true,
              "portMappings": [
                {
                  "containerPort": 8080,
                  "protocol": "tcp"
                }
              ],
              "environment": [
                {
                  "name": "ASPNETCORE_ENVIRONMENT",
                  "value": "Production"
                },
                {
                  "name": "ASPNETCORE_URLS",
                  "value": "http://+:8080"
                },
                {
                  "name": "UseInMemoryDatabase",
                  "value": "false"
                },
                {
                  "name": "ConnectionStrings__DefaultConnection",
                  "value": "Data Source=servermonitoring.db"
                },
                {
                  "name": "JWT_ISSUER",
                  "value": "ServerMonitoringAPI"
                },
                {
                  "name": "JWT_AUDIENCE",
                  "value": "ServerMonitoringClient"
                }
              ],
              "secrets": [
                {
                  "name": "JWT_SECRET_KEY",
                  "valueFrom": "arn:aws:secretsmanager:${{ env.AWS_REGION }}:${{ secrets.AWS_ACCOUNT_ID }}:secret:servermonitoring/JWT_SECRET_KEY"
                }
              ],
              "logConfiguration": {
                "logDriver": "awslogs",
                "options": {
                  "awslogs-create-group": "true",
                  "awslogs-group": "/ecs/servermonitoring-api",
                  "awslogs-region": "${{ env.AWS_REGION }}",
                  "awslogs-stream-prefix": "ecs"
                }
              },
              "healthCheck": {
                "command": ["CMD-SHELL", "curl -f http://localhost:8080/health || exit 1"],
                "interval": 30,
                "timeout": 5,
                "retries": 3,
                "startPeriod": 180
              }
            }
          ]
        }
        EOF

    - name: Register API task definition
      id: api-task-def
      run: |
        TASK_DEF_ARN=$(aws ecs register-task-definition --cli-input-json file://api-task-definition.json --query 'taskDefinition.taskDefinitionArn' --output text)
        echo "TASK_DEF_ARN=$TASK_DEF_ARN" >> $GITHUB_OUTPUT

    - name: Deploy to ECS
      run: |
        SERVICE_EXISTS=$(aws ecs describe-services --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_API_SERVICE }} --query 'services[0].status' --output text 2>/dev/null || echo "MISSING")
        
        if [ "$SERVICE_EXISTS" = "ACTIVE" ]; then
          echo "Service exists, updating with new task definition..."
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_API_SERVICE }} \
            --task-definition ${{ steps.api-task-def.outputs.TASK_DEF_ARN }} \
            --force-new-deployment \
            --health-check-grace-period-seconds 300
          
          echo "âœ… Service updated successfully!"
          exit 0
        fi
        
        echo "Creating new service..."
        
        SUBNETS=$(aws ec2 describe-subnets --query 'Subnets[*].SubnetId' --output json)
        echo "Subnets: $SUBNETS"
        
        VPC_ID=$(aws ec2 describe-subnets --query 'Subnets[0].VpcId' --output text)
        echo "VPC: $VPC_ID"
        
        if [ "$SUBNETS" = "[]" ] || [ -z "$SUBNETS" ]; then
          echo "ERROR: No subnets available!"
          exit 1
        fi
        
        # Check if subnets have internet gateway routes
        SUBNET_ID=$(echo $SUBNETS | jq -r '.[0]')
        echo "Checking internet connectivity for subnet: $SUBNET_ID"
        
        ROUTE_TABLE=$(aws ec2 describe-route-tables \
          --filters "Name=association.subnet-id,Values=$SUBNET_ID" \
          --query 'RouteTables[0].RouteTableId' \
          --output text 2>/dev/null || \
          aws ec2 describe-route-tables \
            --filters "Name=vpc-id,Values=$VPC_ID" "Name=association.main,Values=true" \
            --query 'RouteTables[0].RouteTableId' \
            --output text)
        
        echo "Route table: $ROUTE_TABLE"
        
        IGW_ROUTE=$(aws ec2 describe-route-tables \
          --route-table-ids $ROUTE_TABLE \
          --query 'RouteTables[0].Routes[?DestinationCidrBlock==`0.0.0.0/0`].GatewayId' \
          --output text 2>/dev/null || echo "None")
        
        echo "Internet Gateway route: $IGW_ROUTE"
        
        # Create VPC Endpoints for ECR if no internet gateway (CRITICAL FIX)
        if [ "$IGW_ROUTE" = "None" ] || [ -z "$IGW_ROUTE" ]; then
          echo "âš ï¸  WARNING: No internet gateway found! Creating VPC endpoints with Private DNS..."
          
          # Delete existing broken VPC endpoints (without DNS enabled) and recreate them properly
          echo "Cleaning up any existing VPC endpoints without Private DNS..."
          EXISTING_ENDPOINTS=$(aws ec2 describe-vpc-endpoints \
            --filters Name=vpc-id,Values=$VPC_ID \
            --query 'VpcEndpoints[?PrivateDnsEnabled==`false` && VpcEndpointType==`Interface`].VpcEndpointId' \
            --output text)
          
          if [ ! -z "$EXISTING_ENDPOINTS" ]; then
            echo "Deleting endpoints without DNS: $EXISTING_ENDPOINTS"
            for ENDPOINT_ID in $EXISTING_ENDPOINTS; do
              aws ec2 delete-vpc-endpoints --vpc-endpoint-ids $ENDPOINT_ID 2>/dev/null || true
            done
            echo "Waiting 10 seconds for deletions..."
            sleep 10
          fi
          
          # Create VPC endpoint for ECR API
          aws ec2 create-vpc-endpoint \
            --vpc-id $VPC_ID \
            --vpc-endpoint-type Interface \
            --service-name com.amazonaws.${{ env.AWS_REGION }}.ecr.api \
            --subnet-ids $(echo $SUBNETS | jq -r 'join(" ")') \
            --security-group-ids $SG_ID \
            --private-dns-enabled 2>/dev/null || echo "ECR API endpoint may already exist"
          
          # Create VPC endpoint for ECR Docker
          aws ec2 create-vpc-endpoint \
            --vpc-id $VPC_ID \
            --vpc-endpoint-type Interface \
            --service-name com.amazonaws.${{ env.AWS_REGION }}.ecr.dkr \
            --subnet-ids $(echo $SUBNETS | jq -r 'join(" ")') \
            --security-group-ids $SG_ID \
            --private-dns-enabled 2>/dev/null || echo "ECR DKR endpoint may already exist"
          
          # Create VPC endpoint for S3 (needed for ECR layers)
          aws ec2 create-vpc-endpoint \
            --vpc-id $VPC_ID \
            --vpc-endpoint-type Gateway \
            --service-name com.amazonaws.${{ env.AWS_REGION }}.s3 \
            --route-table-ids $ROUTE_TABLE 2>/dev/null || echo "S3 endpoint may already exist"
          
          # Create VPC endpoint for Secrets Manager (CRITICAL - tasks pull secrets at startup)
          aws ec2 create-vpc-endpoint \
            --vpc-id $VPC_ID \
            --vpc-endpoint-type Interface \
            --service-name com.amazonaws.${{ env.AWS_REGION }}.secretsmanager \
            --subnet-ids $(echo $SUBNETS | jq -r 'join(" ")') \
            --security-group-ids $SG_ID \
            --private-dns-enabled 2>/dev/null || echo "Secrets Manager endpoint may already exist"
          
          # Create VPC endpoint for CloudWatch Logs
          aws ec2 create-vpc-endpoint \
            --vpc-id $VPC_ID \
            --vpc-endpoint-type Interface \
            --service-name com.amazonaws.${{ env.AWS_REGION }}.logs \
            --subnet-ids $(echo $SUBNETS | jq -r 'join(" ")') \
            --security-group-ids $SG_ID \
            --private-dns-enabled 2>/dev/null || echo "CloudWatch Logs endpoint may already exist"
          
          echo "âœ… VPC endpoints created with Private DNS enabled (ECR, S3, Secrets Manager, CloudWatch)"
          echo "âœ… Tasks can now resolve *.amazonaws.com DNS names via private AWS network"
        else
          echo "âœ… Internet gateway found: $IGW_ROUTE"
        fi
        
        # Force delete old security group if exists
        EXISTING_SG=$(aws ec2 describe-security-groups \
          --filters "Name=group-name,Values=servermonitoring-api-sg" \
          --query 'SecurityGroups[0].GroupId' \
          --output text 2>/dev/null || echo "None")
        
        if [ "$EXISTING_SG" != "None" ]; then
          echo "Found existing security group: $EXISTING_SG"
          echo "Waiting for network interfaces to detach..."
          
          # Wait up to 60 seconds for ENIs to detach
          for i in {1..12}; do
            ENI_COUNT=$(aws ec2 describe-network-interfaces \
              --filters "Name=group-id,Values=$EXISTING_SG" \
              --query 'length(NetworkInterfaces)' \
              --output text 2>/dev/null || echo "0")
            
            echo "Attempt $i: $ENI_COUNT network interfaces still attached"
            
            if [ "$ENI_COUNT" = "0" ]; then
              echo "All network interfaces detached!"
              break
            fi
            
            sleep 5
          done
          
          echo "Deleting old security group..."
          aws ec2 delete-security-group --group-id $EXISTING_SG 2>/dev/null || echo "Could not delete, reusing existing SG"
          sleep 2
        fi
        
        # Create fresh security group (or reuse if deletion failed)
        echo "Creating new security group..."
        SG_ID=$(aws ec2 create-security-group \
          --group-name servermonitoring-api-sg \
          --description "Security group for Server Monitoring API" \
          --vpc-id $VPC_ID \
          --query 'GroupId' \
          --output text 2>/dev/null || \
          aws ec2 describe-security-groups \
            --filters "Name=group-name,Values=servermonitoring-api-sg" "Name=vpc-id,Values=$VPC_ID" \
            --query 'SecurityGroups[0].GroupId' \
            --output text)
        
        echo "Created SG: $SG_ID"
        sleep 2
        
        # EXPLICITLY add egress rule for ALL traffic (CRITICAL for ECR access)
        echo "Adding egress rule for internet access..."
        aws ec2 authorize-security-group-egress \
            --group-id $SG_ID \
            --ip-permissions IpProtocol=-1,IpRanges='[{CidrIp=0.0.0.0/0}]' 2>/dev/null || echo "Egress rule may already exist"
        
        # Add ingress rule for API
        aws ec2 authorize-security-group-ingress \
            --group-id $SG_ID \
            --protocol tcp \
            --port 8080 \
            --cidr 0.0.0.0/0 2>/dev/null || echo "API ingress rule may already exist"
        
        # CRITICAL: Add ingress rule for HTTPS (443) for VPC endpoint access
        echo "Adding HTTPS ingress rule for VPC endpoint connectivity..."
        VPC_CIDR=$(aws ec2 describe-vpcs --vpc-ids $VPC_ID --query 'Vpcs[0].CidrBlock' --output text)
        aws ec2 authorize-security-group-ingress \
            --group-id $SG_ID \
            --protocol tcp \
            --port 443 \
            --cidr $VPC_CIDR 2>/dev/null || echo "HTTPS ingress may already exist"
        
        echo "VPC CIDR: $VPC_CIDR - Security group now allows HTTPS from VPC for endpoint access"
        
        # Verify egress rules
        echo "Verifying security group rules..."
        aws ec2 describe-security-groups --group-ids $SG_ID --query 'SecurityGroups[0].{Ingress:IpPermissions,Egress:IpPermissionsEgress}' --output json
          
        # Create service with JSON format
        aws ecs create-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service-name ${{ env.ECS_API_SERVICE }} \
            --task-definition ${{ steps.api-task-def.outputs.TASK_DEF_ARN }} \
            --desired-count 1 \
            --launch-type FARGATE \
            --health-check-grace-period-seconds 300 \
            --network-configuration "{
              \"awsvpcConfiguration\": {
                \"subnets\": $SUBNETS,
                \"securityGroups\": [\"$SG_ID\"],
                \"assignPublicIp\": \"ENABLED\"
              }
            }"


    - name: Check API service created
      run: |
        echo "API service created. Waiting for task to start..."
        sleep 30
        
        # Wait for task to be running
        for i in {1..30}; do
          TASK_COUNT=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_API_SERVICE }} \
            --query 'services[0].runningCount' \
            --output text)
          
          echo "Attempt $i: $TASK_COUNT tasks running"
          
          if [ "$TASK_COUNT" = "1" ]; then
            echo "API task is running!"
            break
          fi
          
          sleep 10
        done
        
        aws ecs describe-services \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.ECS_API_SERVICE }} \
          --query 'services[0].{Status:status,Running:runningCount,Desired:desiredCount}' \
          --output table

    - name: Get API service IP
      id: api-ip
      run: |
        echo "Getting API service public IP..."
        API_TASK_ARN=$(aws ecs list-tasks \
          --cluster ${{ env.ECS_CLUSTER }} \
          --service-name ${{ env.ECS_API_SERVICE }} \
          --query 'taskArns[0]' \
          --output text)
        
        if [ "$API_TASK_ARN" = "None" ] || [ -z "$API_TASK_ARN" ]; then
          echo "ERROR: No API task found!"
          exit 1
        fi
        
        API_ENI_ID=$(aws ecs describe-tasks \
          --cluster ${{ env.ECS_CLUSTER }} \
          --tasks $API_TASK_ARN \
          --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' \
          --output text)
        
        API_PUBLIC_IP=$(aws ec2 describe-network-interfaces \
          --network-interface-ids $API_ENI_ID \
          --query 'NetworkInterfaces[0].Association.PublicIp' \
          --output text)
        
        echo "API_PUBLIC_IP=$API_PUBLIC_IP" >> $GITHUB_OUTPUT
        echo "âœ… API Service IP: $API_PUBLIC_IP"

    - name: Create Web task definition with dynamic API URL
      run: |
        API_URL="http://${{ steps.api-ip.outputs.API_PUBLIC_IP }}:8080"
        echo "Creating web task definition with API_URL=$API_URL"
        
        cat > web-task-definition.json <<EOF
        {
          "family": "servermonitoring-web",
          "networkMode": "awsvpc",
          "requiresCompatibilities": ["FARGATE"],
          "cpu": "256",
          "memory": "512",
          "executionRoleArn": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/ecsTaskExecutionRole-ServerMonitoring",
          "taskRoleArn": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/ecsTaskRole-ServerMonitoring",
          "containerDefinitions": [
            {
              "name": "${{ env.WEB_CONTAINER_NAME }}",
              "image": "${{ env.WEB_IMAGE }}",
              "cpu": 256,
              "memory": 512,
              "essential": true,
              "portMappings": [
                {
                  "containerPort": 80,
                  "protocol": "tcp"
                }
              ],
              "environment": [
                {
                  "name": "API_URL",
                  "value": "$API_URL"
                },
                {
                  "name": "VITE_API_URL",
                  "value": "$API_URL"
                }
              ],
              "logConfiguration": {
                "logDriver": "awslogs",
                "options": {
                  "awslogs-create-group": "true",
                  "awslogs-group": "/ecs/servermonitoring-web",
                  "awslogs-region": "${{ env.AWS_REGION }}",
                  "awslogs-stream-prefix": "ecs"
                }
              },
              "healthCheck": {
                "command": ["CMD-SHELL", "curl -f http://localhost:80/ || exit 1"],
                "interval": 30,
                "timeout": 5,
                "retries": 3,
                "startPeriod": 60
              }
            }
          ]
        }
        EOF

    - name: Register Web task definition
      id: web-task-def
      run: |
        TASK_DEF_ARN=$(aws ecs register-task-definition --cli-input-json file://web-task-definition.json --query 'taskDefinition.taskDefinitionArn' --output text)
        echo "TASK_DEF_ARN=$TASK_DEF_ARN" >> $GITHUB_OUTPUT
        echo "âœ… Web task definition registered: $TASK_DEF_ARN"

    - name: Deploy Web to ECS
      run: |
        # Get subnets and VPC (already created from API deployment)
        SUBNETS=$(aws ec2 describe-subnets --query 'Subnets[*].SubnetId' --output json)
        VPC_ID=$(aws ec2 describe-subnets --query 'Subnets[0].VpcId' --output text)
        
        # Force delete old web security group if exists
        EXISTING_SG_WEB=$(aws ec2 describe-security-groups \
          --filters "Name=group-name,Values=servermonitoring-web-sg" \
          --query 'SecurityGroups[0].GroupId' \
          --output text 2>/dev/null || echo "None")
        
        if [ "$EXISTING_SG_WEB" != "None" ]; then
          echo "Found existing web security group: $EXISTING_SG_WEB"
          echo "Waiting for network interfaces to detach..."
          
          for i in {1..12}; do
            ENI_COUNT=$(aws ec2 describe-network-interfaces \
              --filters "Name=group-id,Values=$EXISTING_SG_WEB" \
              --query 'length(NetworkInterfaces)' \
              --output text 2>/dev/null || echo "0")
            
            echo "Attempt $i: $ENI_COUNT network interfaces still attached"
            
            if [ "$ENI_COUNT" = "0" ]; then
              break
            fi
            
            sleep 5
          done
          
          aws ec2 delete-security-group --group-id $EXISTING_SG_WEB 2>/dev/null || echo "Could not delete, reusing existing SG"
          sleep 2
        fi
        
        # Create fresh web security group (or reuse if deletion failed)
        echo "Creating new web security group..."
        SG_ID_WEB=$(aws ec2 create-security-group \
          --group-name servermonitoring-web-sg \
          --description "Security group for Server Monitoring Web" \
          --vpc-id $VPC_ID \
          --query 'GroupId' \
          --output text 2>/dev/null || \
          aws ec2 describe-security-groups \
            --filters "Name=group-name,Values=servermonitoring-web-sg" "Name=vpc-id,Values=$VPC_ID" \
            --query 'SecurityGroups[0].GroupId' \
            --output text)
        
        echo "Web SG: $SG_ID_WEB"
        sleep 2
        
        # EXPLICITLY add egress rule for ALL traffic (CRITICAL for ECR access)
        echo "Adding egress rule for web..."
        aws ec2 authorize-security-group-egress \
            --group-id $SG_ID_WEB \
            --ip-permissions IpProtocol=-1,IpRanges='[{CidrIp=0.0.0.0/0}]' 2>/dev/null || echo "Egress rule may already exist"
        
        # Add ingress rule
        aws ec2 authorize-security-group-ingress \
            --group-id $SG_ID_WEB \
            --protocol tcp \
            --port 80 \
            --cidr 0.0.0.0/0 2>/dev/null || true
        
        # Allow web tasks to access VPC endpoints (ECR)
        echo "Adding VPC endpoint access for web tasks..."
        aws ec2 authorize-security-group-ingress \
            --group-id sg-0796900368936631a \
            --protocol tcp \
            --port 443 \
            --source-group $SG_ID_WEB 2>/dev/null || echo "VPC endpoint rule may already exist"
        
        # Check if web service exists
        WEB_SERVICE_EXISTS=$(aws ecs describe-services --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_WEB_SERVICE }} --query 'services[0].status' --output text 2>/dev/null || echo "MISSING")
        
        if [ "$WEB_SERVICE_EXISTS" = "ACTIVE" ]; then
          echo "Web service exists, updating with new task definition..."
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_WEB_SERVICE }} \
            --task-definition ${{ steps.web-task-def.outputs.TASK_DEF_ARN }} \
            --force-new-deployment \
            --health-check-grace-period-seconds 300
          
          echo "âœ… Web service updated successfully!"
        else
          # Create web service
          echo "Creating web service..."
          aws ecs create-service \
              --cluster ${{ env.ECS_CLUSTER }} \
              --service-name ${{ env.ECS_WEB_SERVICE }} \
              --task-definition ${{ steps.web-task-def.outputs.TASK_DEF_ARN }} \
              --desired-count 1 \
              --launch-type FARGATE \
              --health-check-grace-period-seconds 300 \
              --network-configuration "{
                \"awsvpcConfiguration\": {
                  \"subnets\": $SUBNETS,
                  \"securityGroups\": [\"$SG_ID_WEB\"],
                  \"assignPublicIp\": \"ENABLED\"
                }
              }"
        fi

    - name: Check Web service created
      run: |
        echo "Web service created. Checking initial status..."
        sleep 10
        aws ecs describe-services \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.ECS_WEB_SERVICE }} \
          --query 'services[0].{Status:status,Running:runningCount,Desired:desiredCount}' \
          --output table

    - name: Get service URLs
      run: |
        echo "â³ Waiting for tasks to start..."
        sleep 30
        
        # Get API URL
        API_TASK_ARN=$(aws ecs list-tasks --cluster ${{ env.ECS_CLUSTER }} --service-name ${{ env.ECS_API_SERVICE }} --query 'taskArns[0]' --output text)
        
        if [ "$API_TASK_ARN" != "None" ] && [ -n "$API_TASK_ARN" ]; then
          API_ENI_ID=$(aws ecs describe-tasks --cluster ${{ env.ECS_CLUSTER }} --tasks $API_TASK_ARN --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' --output text)
          API_PUBLIC_IP=$(aws ec2 describe-network-interfaces --network-interface-ids $API_ENI_ID --query 'NetworkInterfaces[0].Association.PublicIp' --output text)
        else
          API_PUBLIC_IP="pending"
        fi
        
        # Get Web URL
        WEB_TASK_ARN=$(aws ecs list-tasks --cluster ${{ env.ECS_CLUSTER }} --service-name ${{ env.ECS_WEB_SERVICE }} --query 'taskArns[0]' --output text)
        
        if [ "$WEB_TASK_ARN" != "None" ] && [ -n "$WEB_TASK_ARN" ]; then
          WEB_ENI_ID=$(aws ecs describe-tasks --cluster ${{ env.ECS_CLUSTER }} --tasks $WEB_TASK_ARN --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' --output text)
          WEB_PUBLIC_IP=$(aws ec2 describe-network-interfaces --network-interface-ids $WEB_ENI_ID --query 'NetworkInterfaces[0].Association.PublicIp' --output text)
        else
          WEB_PUBLIC_IP="pending"
        fi
        
        echo "========================================="
        echo "ðŸŒ WEB UI: http://$WEB_PUBLIC_IP"
        echo "ðŸ”§ API: http://$API_PUBLIC_IP:8080/swagger"
        echo "â¤ï¸  Health: http://$API_PUBLIC_IP:8080/health"
        echo "========================================="
        echo ""
        echo "Access your application at: http://$WEB_PUBLIC_IP"
        echo "If IPs show 'pending', tasks are still starting. Check ECS console."
        echo "========================================="
        
        # Export IPs for next step
        echo "WEB_IP=$WEB_PUBLIC_IP" >> $GITHUB_ENV
        echo "API_IP=$API_PUBLIC_IP" >> $GITHUB_ENV
    
    - name: Update deployment URLs file
      run: |
        cat > CURRENT_DEPLOYMENT.md <<EOF
        # ðŸš€ Current Deployment URLs
        
        **Last Updated:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')  
        **Commit:** ${{ github.sha }}
        
        ---
        
        ## ðŸŒ Access Your Application
        
        ### Web Application (React Frontend)
        **URL:** http://${{ env.WEB_IP }}
        
        - Login Page: http://${{ env.WEB_IP }}/login
        - Dashboard: http://${{ env.WEB_IP }}/
        
        **Test Credentials:**
        - Admin: \`admin\` / \`Admin@123\`
        - User: \`user\` / \`User@123\`
        
        ---
        
        ### API Backend (.NET)
        **Base URL:** http://${{ env.API_IP }}:8080
        
        - Swagger UI: http://${{ env.API_IP }}:8080/swagger
        - Health Check: http://${{ env.API_IP }}:8080/health
        - API v1: http://${{ env.API_IP }}:8080/api/v1/
        
        ---
        
        ## ðŸ“Š Service Status
        
        | Service | Status | IP Address |
        |---------|--------|------------|
        | Web (React) | âœ… Running | ${{ env.WEB_IP }} |
        | API (.NET) | âœ… Running | ${{ env.API_IP }} |
        
        ---
        
        ## ðŸ”„ Why IPs Change
        
        ECS Fargate tasks are destroyed and recreated with each deployment, receiving new public IPs. This is normal behavior.
        
        **Always check this file for the latest URLs after deployment.**
        
        ---
        
        ## ðŸ—ï¸ Infrastructure Details
        
        - **Cloud Provider:** AWS (us-east-1)
        - **Orchestration:** ECS Fargate
        - **Container Registry:** Amazon ECR
        - **Deployment:** GitHub Actions CI/CD
        - **Network:** Public subnets with Internet Gateway
        
        EOF
        
        git config user.name "GitHub Actions Bot"
        git config user.email "actions@github.com"
        git add CURRENT_DEPLOYMENT.md
        git diff --staged --quiet || git commit -m "Update deployment URLs [skip ci]"
        git push origin main || echo "No changes to push"

