name: Deploy to AWS ECS

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  ECR_API_REPOSITORY: servermonitoring-api
  ECR_WEB_REPOSITORY: servermonitoring-web
  ECS_CLUSTER: servermonitoring-cluster
  ECS_API_SERVICE: servermonitoring-api-service
  ECS_WEB_SERVICE: servermonitoring-web-service
  API_CONTAINER_NAME: api
  WEB_CONTAINER_NAME: web

jobs:
  # Backend Unit Tests
  backend-unit-tests:
    name: Backend Unit Tests
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: '10.0.x'
    
    - name: Restore dependencies
      run: dotnet restore tests/ServerMonitoring.UnitTests/ServerMonitoring.UnitTests.csproj
    
    - name: Run unit tests
      run: dotnet test tests/ServerMonitoring.UnitTests/ServerMonitoring.UnitTests.csproj --no-restore --verbosity normal --logger "trx;LogFileName=unit-test-results.trx"
    
    - name: Upload test results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: unit-test-results
        path: tests/ServerMonitoring.UnitTests/TestResults/unit-test-results.trx

  # Backend Integration Tests (using real API) - DISABLED
  # backend-integration-tests:
  #   name: Backend Integration Tests
  #   runs-on: ubuntu-latest
  #   
  #   steps:
  #   - name: Checkout code
  #     uses: actions/checkout@v3
  #   
  #   - name: Setup .NET
  #     uses: actions/setup-dotnet@v3
  #     with:
  #       dotnet-version: '10.0.x'
  #   
  #   - name: Restore dependencies
  #     run: dotnet restore tests/ServerMonitoring.IntegrationTests/ServerMonitoring.IntegrationTests.csproj
  #   
  #   - name: Run integration tests
  #     run: dotnet test tests/ServerMonitoring.IntegrationTests/ServerMonitoring.IntegrationTests.csproj --no-restore --verbosity normal --logger "trx;LogFileName=integration-test-results.trx"
  #   
  #   - name: Upload test results
  #     if: always()
  #     uses: actions/upload-artifact@v4
  #     with:
  #       name: integration-test-results
  #       path: tests/ServerMonitoring.IntegrationTests/TestResults/integration-test-results.trx

  # Frontend Tests
  frontend-tests:
    name: Frontend Tests
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: ServerMonitoring.Web/package-lock.json
    
    - name: Install dependencies
      working-directory: ServerMonitoring.Web
      run: npm ci
    
    - name: Run tests
      working-directory: ServerMonitoring.Web
      run: npm test -- --run --reporter=verbose
    
    - name: Upload coverage
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: frontend-coverage
        path: ServerMonitoring.Web/coverage

  # Deployment (only runs if all tests pass)
  deploy:
    needs: [backend-unit-tests, frontend-tests]
    name: Deploy to ECS
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1

    - name: Create ECR repositories if they don't exist
      run: |
        # Create API repository
        aws ecr describe-repositories --repository-names ${{ env.ECR_API_REPOSITORY }} 2>/dev/null || \
          aws ecr create-repository --repository-name ${{ env.ECR_API_REPOSITORY }}
        
        # Create Web repository
        aws ecr describe-repositories --repository-names ${{ env.ECR_WEB_REPOSITORY }} 2>/dev/null || \
          aws ecr create-repository --repository-name ${{ env.ECR_WEB_REPOSITORY }}

    - name: Build, tag, and push API image to Amazon ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        docker build -t $ECR_REGISTRY/$ECR_API_REPOSITORY:$IMAGE_TAG -f src/Presentation/ServerMonitoring.API/Dockerfile .
        docker tag $ECR_REGISTRY/$ECR_API_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_API_REPOSITORY:latest
        docker push $ECR_REGISTRY/$ECR_API_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_API_REPOSITORY:latest
        echo "API_IMAGE=$ECR_REGISTRY/$ECR_API_REPOSITORY:$IMAGE_TAG" >> $GITHUB_ENV

    - name: Build, tag, and push Web image to Amazon ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        docker build -t $ECR_REGISTRY/$ECR_WEB_REPOSITORY:$IMAGE_TAG -f ServerMonitoring.Web/Dockerfile ServerMonitoring.Web
        docker tag $ECR_REGISTRY/$ECR_WEB_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_WEB_REPOSITORY:latest
        docker push $ECR_REGISTRY/$ECR_WEB_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_WEB_REPOSITORY:latest
        echo "WEB_IMAGE=$ECR_REGISTRY/$ECR_WEB_REPOSITORY:$IMAGE_TAG" >> $GITHUB_ENV

    - name: Create IAM roles for ECS
      run: |
        # Create ECS Task Execution Role
        EXEC_ROLE_EXISTS=$(aws iam get-role --role-name ecsTaskExecutionRole-ServerMonitoring --query 'Role.RoleName' --output text 2>/dev/null || echo "None")
        
        if [ "$EXEC_ROLE_EXISTS" = "None" ]; then
          echo "Creating ecsTaskExecutionRole-ServerMonitoring..."
          
          cat > trust-policy.json <<EOF
        {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "Service": "ecs-tasks.amazonaws.com"
              },
              "Action": "sts:AssumeRole"
            }
          ]
        }
        EOF
          
          aws iam create-role \
            --role-name ecsTaskExecutionRole-ServerMonitoring \
            --assume-role-policy-document file://trust-policy.json
          
          aws iam attach-role-policy \
            --role-name ecsTaskExecutionRole-ServerMonitoring \
            --policy-arn arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
          
          echo "Waiting for role to be available..."
          sleep 10
        else
          echo "ecsTaskExecutionRole-ServerMonitoring already exists"
        fi
        
        # Create ECS Task Role
        TASK_ROLE_EXISTS=$(aws iam get-role --role-name ecsTaskRole-ServerMonitoring --query 'Role.RoleName' --output text 2>/dev/null || echo "None")
        
        if [ "$TASK_ROLE_EXISTS" = "None" ]; then
          echo "Creating ecsTaskRole-ServerMonitoring..."
          
          aws iam create-role \
            --role-name ecsTaskRole-ServerMonitoring \
            --assume-role-policy-document file://trust-policy.json
          
          echo "Waiting for role to be available..."
          sleep 10
        else
          echo "ecsTaskRole-ServerMonitoring already exists"
        fi

    - name: Create/Update secrets in AWS Secrets Manager
      run: |
        # Create JWT secret if it doesn't exist
        JWT_SECRET=$(openssl rand -base64 32)
        aws secretsmanager create-secret \
          --name servermonitoring/JWT_SECRET_KEY \
          --secret-string "$JWT_SECRET" 2>/dev/null || \
          echo "JWT secret already exists"
        
        # Create DB password
        DB_PASSWORD=$(openssl rand -base64 16)
        aws secretsmanager create-secret \
          --name servermonitoring/DB_SA_PASSWORD \
          --secret-string "$DB_PASSWORD" 2>/dev/null || \
          echo "DB password already exists"
        
        # Create Redis password
        REDIS_PASSWORD=$(openssl rand -base64 16)
        aws secretsmanager create-secret \
          --name servermonitoring/REDIS_PASSWORD \
          --secret-string "$REDIS_PASSWORD" 2>/dev/null || \
          echo "Redis password already exists"
        
        # Give execution role permission to read secrets
        POLICY_EXISTS=$(aws iam list-attached-role-policies \
          --role-name ecsTaskExecutionRole-ServerMonitoring \
          --query "AttachedPolicies[?PolicyArn=='arn:aws:iam::aws:policy/SecretsManagerReadWrite'].PolicyArn" \
          --output text)
        
        if [ -z "$POLICY_EXISTS" ]; then
          aws iam attach-role-policy \
            --role-name ecsTaskExecutionRole-ServerMonitoring \
            --policy-arn arn:aws:iam::aws:policy/SecretsManagerReadWrite
        fi

    - name: Create API task definition
      run: |
        cat > api-task-definition.json <<EOF
        {
          "family": "servermonitoring-api",
          "networkMode": "awsvpc",
          "requiresCompatibilities": ["FARGATE"],
          "cpu": "512",
          "memory": "1024",
          "executionRoleArn": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/ecsTaskExecutionRole-ServerMonitoring",
          "taskRoleArn": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/ecsTaskRole-ServerMonitoring",
          "volumes": [
            {
              "name": "database-storage"
            }
          ],
          "containerDefinitions": [
            {
              "name": "${{ env.API_CONTAINER_NAME }}",
              "image": "${{ env.API_IMAGE }}",
              "cpu": 512,
              "memory": 1024,
              "essential": true,
              "mountPoints": [
                {
                  "sourceVolume": "database-storage",
                  "containerPath": "/data",
                  "readOnly": false
                }
              ],
              "portMappings": [
                {
                  "containerPort": 8080,
                  "protocol": "tcp"
                }
              ],
              "environment": [
                {
                  "name": "ASPNETCORE_ENVIRONMENT",
                  "value": "Production"
                },
                {
                  "name": "ASPNETCORE_URLS",
                  "value": "http://+:8080"
                },
                {
                  "name": "UseInMemoryDatabase",
                  "value": "false"
                },
                {
                  "name": "ConnectionStrings__DefaultConnection",
                  "value": "Data Source=/data/servermonitoring.db"
                },
                {
                  "name": "JwtSettings__Issuer",
                  "value": "ServerMonitoringAPI"
                },
                {
                  "name": "JwtSettings__Audience",
                  "value": "ServerMonitoringClient"
                },
                {
                  "name": "JwtSettings__AccessTokenExpirationMinutes",
                  "value": "60"
                }
              ],
              "secrets": [
                {
                  "name": "JwtSettings__SecretKey",
                  "valueFrom": "arn:aws:secretsmanager:${{ env.AWS_REGION }}:${{ secrets.AWS_ACCOUNT_ID }}:secret:servermonitoring/JWT_SECRET_KEY"
                }
              ],
              "logConfiguration": {
                "logDriver": "awslogs",
                "options": {
                  "awslogs-create-group": "true",
                  "awslogs-group": "/ecs/servermonitoring-api",
                  "awslogs-region": "${{ env.AWS_REGION }}",
                  "awslogs-stream-prefix": "ecs"
                }
              },
              "healthCheck": {
                "command": ["CMD-SHELL", "curl -f http://localhost:8080/health || exit 1"],
                "interval": 30,
                "timeout": 5,
                "retries": 3,
                "startPeriod": 180
              }
            }
          ]
        }
        EOF

    - name: Register API task definition
      id: api-task-def
      run: |
        TASK_DEF_ARN=$(aws ecs register-task-definition --cli-input-json file://api-task-definition.json --query 'taskDefinition.taskDefinitionArn' --output text)
        echo "TASK_DEF_ARN=$TASK_DEF_ARN" >> $GITHUB_OUTPUT

    - name: Setup Application Load Balancer
      run: |
        echo "üîß Setting up Application Load Balancer..."
        
        # Step 1: Query all available subnets
        echo "üìã Querying available subnets..."
        ALL_SUBNETS=$(aws ec2 describe-subnets --query 'Subnets[*].[SubnetId,AvailabilityZone,VpcId]' --output text)
        
        if [ -z "$ALL_SUBNETS" ]; then
          echo "‚ùå No subnets found in AWS account"
          echo "Creating default VPC and subnets..."
          aws ec2 create-default-vpc
          sleep 5
          ALL_SUBNETS=$(aws ec2 describe-subnets --query 'Subnets[*].[SubnetId,AvailabilityZone,VpcId]' --output text)
        fi
        
        echo "Available subnets:"
        echo "$ALL_SUBNETS"
        
        # Parse subnets into arrays
        SUBNET_IDS=($(echo "$ALL_SUBNETS" | awk '{print $1}'))
        SUBNET_AZS=($(echo "$ALL_SUBNETS" | awk '{print $2}'))
        SUBNET_VPCS=($(echo "$ALL_SUBNETS" | awk '{print $3}'))
        SUBNET_COUNT=${#SUBNET_IDS[@]}
        
        echo "üìä Found $SUBNET_COUNT total subnet(s)"
        
        # Step 2: If only 1 subnet, create a second one automatically
        if [ $SUBNET_COUNT -lt 2 ]; then
          echo "‚ö†Ô∏è  Only 1 subnet found - ALB requires 2+ subnets"
          echo "üîß Auto-creating second subnet in different AZ..."
          
          VPC_ID=${SUBNET_VPCS[0]}
          EXISTING_AZ=${SUBNET_AZS[0]}
          
          # Get VPC CIDR
          VPC_CIDR=$(aws ec2 describe-vpcs --vpc-ids $VPC_ID --query 'Vpcs[0].CidrBlock' --output text)
          echo "VPC CIDR: $VPC_CIDR"
          
          # Get different AZ from the existing subnet
          ALL_AZS=$(aws ec2 describe-availability-zones --query 'AvailabilityZones[*].ZoneName' --output text)
          NEW_AZ=""
          for az in $ALL_AZS; do
            if [ "$az" != "$EXISTING_AZ" ]; then
              NEW_AZ=$az
              break
            fi
          done
          
          if [ -z "$NEW_AZ" ]; then
            echo "‚ùå Could not find another availability zone"
            exit 1
          fi
          
          echo "Creating subnet in AZ: $NEW_AZ"
          
          # Calculate new subnet CIDR (use next available /24 block)
          BASE_CIDR=$(echo $VPC_CIDR | cut -d'/' -f1 | cut -d'.' -f1-2)
          NEW_SUBNET_CIDR="${BASE_CIDR}.1.0/24"
          
          NEW_SUBNET_ID=$(aws ec2 create-subnet \
            --vpc-id $VPC_ID \
            --cidr-block $NEW_SUBNET_CIDR \
            --availability-zone $NEW_AZ \
            --query 'Subnet.SubnetId' \
            --output text)
          
          echo "‚úÖ Created subnet: $NEW_SUBNET_ID in $NEW_AZ"
          
          # CRITICAL: Ensure new subnet has internet access for ALB
          echo "üîß Configuring internet access for new subnet..."
          
          # Find or create internet gateway
          IGW_ID=$(aws ec2 describe-internet-gateways \
            --filters "Name=attachment.vpc-id,Values=$VPC_ID" \
            --query 'InternetGateways[0].InternetGatewayId' \
            --output text)
          
          if [ "$IGW_ID" = "None" ] || [ -z "$IGW_ID" ]; then
            echo "Creating Internet Gateway..."
            IGW_ID=$(aws ec2 create-internet-gateway --query 'InternetGateway.InternetGatewayId' --output text)
            aws ec2 attach-internet-gateway --vpc-id $VPC_ID --internet-gateway-id $IGW_ID
            echo "‚úÖ Created and attached IGW: $IGW_ID"
          else
            echo "Using existing IGW: $IGW_ID"
          fi
          
          # Get main route table
          ROUTE_TABLE_ID=$(aws ec2 describe-route-tables \
            --filters "Name=vpc-id,Values=$VPC_ID" "Name=association.main,Values=true" \
            --query 'RouteTables[0].RouteTableId' \
            --output text)
          
          echo "Route table: $ROUTE_TABLE_ID"
          
          # Add route to IGW if not exists
          aws ec2 create-route \
            --route-table-id $ROUTE_TABLE_ID \
            --destination-cidr-block 0.0.0.0/0 \
            --gateway-id $IGW_ID 2>/dev/null || echo "Route to IGW already exists"
          
          echo "‚úÖ New subnet has internet access"
          
          # Add to arrays
          SUBNET_IDS+=($NEW_SUBNET_ID)
          SUBNET_AZS+=($NEW_AZ)
          SUBNET_VPCS+=($VPC_ID)
          SUBNET_COUNT=2
          
          echo "‚úÖ Now have $SUBNET_COUNT subnets"
        fi
        
        # Step 3: Select 2 subnets preferably from different AZs
        SUBNET1=${SUBNET_IDS[0]}
        SUBNET1_AZ=${SUBNET_AZS[0]}
        SUBNET2=""
        
        # Try to find a subnet in a different AZ
        for i in "${!SUBNET_IDS[@]}"; do
          if [ "${SUBNET_AZS[$i]}" != "$SUBNET1_AZ" ]; then
            SUBNET2=${SUBNET_IDS[$i]}
            SUBNET2_AZ=${SUBNET_AZS[$i]}
            break
          fi
        done
        
        # If no different AZ found, just use second subnet
        if [ -z "$SUBNET2" ]; then
          SUBNET2=${SUBNET_IDS[1]}
          SUBNET2_AZ=${SUBNET_AZS[1]}
          echo "‚ö†Ô∏è  Both subnets are in the same AZ - this may cause issues"
        fi
        
        echo "‚úÖ Selected subnets:"
        echo "  Subnet 1: $SUBNET1 (AZ: $SUBNET1_AZ)"
        echo "  Subnet 2: $SUBNET2 (AZ: $SUBNET2_AZ)"
        
        # Get VPC ID from first subnet
        VPC_ID=${SUBNET_VPCS[0]}
        echo "  VPC ID: $VPC_ID"
        
        # Create ALB security group
        ALB_SG_ID=$(aws ec2 describe-security-groups \
          --filters "Name=group-name,Values=servermonitoring-alb-sg" "Name=vpc-id,Values=$VPC_ID" \
          --query 'SecurityGroups[0].GroupId' \
          --output text 2>/dev/null)
        
        if [ "$ALB_SG_ID" = "None" ] || [ -z "$ALB_SG_ID" ]; then
          echo "Creating ALB security group..."
          ALB_SG_ID=$(aws ec2 create-security-group \
            --group-name servermonitoring-alb-sg \
            --description "Security group for ALB" \
            --vpc-id $VPC_ID \
            --query 'GroupId' \
            --output text)
          
          aws ec2 authorize-security-group-ingress \
            --group-id $ALB_SG_ID \
            --protocol tcp \
            --port 80 \
            --cidr 0.0.0.0/0 2>/dev/null || true
          
          aws ec2 authorize-security-group-egress \
            --group-id $ALB_SG_ID \
            --ip-permissions IpProtocol=-1,IpRanges='[{CidrIp=0.0.0.0/0}]' 2>/dev/null || true
        else
          echo "Using existing ALB security group: $ALB_SG_ID"
        fi
        echo "ALB SG: $ALB_SG_ID"
        
        # Update API SG to accept traffic from ALB
        API_SG_ID=$(aws ec2 describe-security-groups \
          --filters "Name=group-name,Values=servermonitoring-api-sg" "Name=vpc-id,Values=$VPC_ID" \
          --query 'SecurityGroups[0].GroupId' \
          --output text 2>/dev/null)
        
        if [ "$API_SG_ID" != "None" ] && [ -n "$API_SG_ID" ]; then
          aws ec2 authorize-security-group-ingress \
            --group-id $API_SG_ID \
            --protocol tcp \
            --port 8080 \
            --source-group $ALB_SG_ID 2>/dev/null || echo "ALB -> API rule exists"
        fi
        
        # Create ALB
        echo "üîç Checking if ALB exists..."
        ALB_ARN=$(aws elbv2 describe-load-balancers \
          --names servermonitoring-alb \
          --query 'LoadBalancers[0].LoadBalancerArn' \
          --output text 2>/dev/null || echo "None")
        
        echo "ALB_ARN result: '$ALB_ARN'"
        
        if [ "$ALB_ARN" = "None" ] || [ -z "$ALB_ARN" ] || [ "$ALB_ARN" = "null" ]; then
          echo "Creating Application Load Balancer..."
          echo "  Subnets: $SUBNET1, $SUBNET2"
          echo "  Security Group: $ALB_SG_ID"
          echo "  VPC: $VPC_ID"
          
          # Create ALB with explicit error handling
          set +e  # Don't exit on error
          ALB_CREATE_OUTPUT=$(aws elbv2 create-load-balancer \
            --name servermonitoring-alb \
            --subnets $SUBNET1 $SUBNET2 \
            --security-groups $ALB_SG_ID \
            --scheme internet-facing \
            --type application \
            --ip-address-type ipv4 2>&1)
          ALB_CREATE_EXIT=$?
          set -e  # Re-enable exit on error
          
          echo "Create ALB exit code: $ALB_CREATE_EXIT"
          
          if [ $ALB_CREATE_EXIT -ne 0 ]; then
            echo "‚ùå Error creating ALB:"
            echo "$ALB_CREATE_OUTPUT"
            exit 1
          fi
          
          ALB_ARN=$(echo "$ALB_CREATE_OUTPUT" | grep -o 'arn:aws:elasticloadbalancing:[^"]*' | head -1)
          
          if [ -z "$ALB_ARN" ]; then
            echo "‚ùå Error: Failed to extract ALB ARN from output"
            echo "$ALB_CREATE_OUTPUT"
            exit 1
          fi
          
          echo "‚úÖ ALB created: $ALB_ARN"
          echo "Waiting for ALB to become active..."
          aws elbv2 wait load-balancer-available --load-balancer-arns $ALB_ARN
        else
          echo "Using existing ALB: $ALB_ARN"
        fi
        
        # Get ALB DNS
        ALB_DNS=$(aws elbv2 describe-load-balancers \
          --load-balancer-arns $ALB_ARN \
          --query 'LoadBalancers[0].DNSName' \
          --output text)
        
        if [ -z "$ALB_DNS" ] || [ "$ALB_DNS" = "None" ]; then
          echo "‚ùå Error: Failed to get ALB DNS"
          exit 1
        fi
        
        echo "‚úÖ ALB DNS: $ALB_DNS"
        
        # Create target group for API
        echo "üîç Checking if API target group exists..."
        API_TG_ARN=$(aws elbv2 describe-target-groups \
          --names servermonitoring-api-tg \
          --query 'TargetGroups[0].TargetGroupArn' \
          --output text 2>/dev/null || echo "None")
        
        echo "API_TG_ARN result: '$API_TG_ARN'"
        
        if [ "$API_TG_ARN" = "None" ] || [ -z "$API_TG_ARN" ] || [ "$API_TG_ARN" = "null" ]; then
          echo "Creating API target group..."
          echo "  VPC: $VPC_ID"
          
          set +e  # Don't exit on error
          TG_CREATE_OUTPUT=$(aws elbv2 create-target-group \
            --name servermonitoring-api-tg \
            --protocol HTTP \
            --port 8080 \
            --vpc-id $VPC_ID \
            --target-type ip \
            --health-check-enabled \
            --health-check-path /health \
            --health-check-interval-seconds 30 \
            --health-check-timeout-seconds 5 \
            --healthy-threshold-count 2 \
            --unhealthy-threshold-count 3 2>&1)
          TG_CREATE_EXIT=$?
          set -e  # Re-enable exit on error
          
          echo "Create TG exit code: $TG_CREATE_EXIT"
          
          if [ $TG_CREATE_EXIT -ne 0 ]; then
            echo "‚ùå Error creating target group:"
            echo "$TG_CREATE_OUTPUT"
            exit 1
          fi
          
          API_TG_ARN=$(echo "$TG_CREATE_OUTPUT" | grep -o 'arn:aws:elasticloadbalancing:[^"]*targetgroup[^"]*' | head -1)
          
          if [ -z "$API_TG_ARN" ]; then
            echo "‚ùå Error: Failed to extract target group ARN"
            echo "$TG_CREATE_OUTPUT"
            exit 1
          fi
        else
          echo "Using existing API target group: $API_TG_ARN"
        fi
        echo "‚úÖ API Target Group: $API_TG_ARN"
        
        # Create listener
        echo "üîç Checking if listener exists..."
        LISTENER_ARN=$(aws elbv2 describe-listeners \
          --load-balancer-arn $ALB_ARN \
          --query 'Listeners[0].ListenerArn' \
          --output text 2>/dev/null || echo "None")
        
        echo "LISTENER_ARN result: '$LISTENER_ARN'"
        
        if [ "$LISTENER_ARN" = "None" ] || [ -z "$LISTENER_ARN" ] || [ "$LISTENER_ARN" = "null" ]; then
          echo "Creating ALB listener..."
          echo "  ALB: $ALB_ARN"
          echo "  Target Group: $API_TG_ARN"
          
          set +e  # Don't exit on error
          LISTENER_CREATE_OUTPUT=$(aws elbv2 create-listener \
            --load-balancer-arn $ALB_ARN \
            --protocol HTTP \
            --port 80 \
            --default-actions Type=forward,TargetGroupArn=$API_TG_ARN 2>&1)
          LISTENER_CREATE_EXIT=$?
          set -e  # Re-enable exit on error
          
          echo "Create listener exit code: $LISTENER_CREATE_EXIT"
          
          if [ $LISTENER_CREATE_EXIT -ne 0 ]; then
            echo "‚ùå Error creating listener:"
            echo "$LISTENER_CREATE_OUTPUT"
            exit 1
          fi
          
          LISTENER_ARN=$(echo "$LISTENER_CREATE_OUTPUT" | grep -o 'arn:aws:elasticloadbalancing:[^"]*listener[^"]*' | head -1)
          
          if [ -z "$LISTENER_ARN" ]; then
            echo "‚ùå Error: Failed to extract listener ARN"
            echo "$LISTENER_CREATE_OUTPUT"
            exit 1
          fi
          echo "‚úÖ Listener created: $LISTENER_ARN"
        else
          echo "Listener already exists - updating to point to current API target group..."
          aws elbv2 modify-listener \
            --listener-arn $LISTENER_ARN \
            --default-actions Type=forward,TargetGroupArn=$API_TG_ARN
          echo "‚úÖ Listener updated: $LISTENER_ARN"
        fi
        
        echo "‚úÖ ALB setup complete!"
        echo "API_URL=http://$ALB_DNS" >> $GITHUB_ENV
        echo "ALB_ARN=$ALB_ARN" >> $GITHUB_ENV
        echo "API_TG_ARN=$API_TG_ARN" >> $GITHUB_ENV

    - name: Deploy to ECS
      run: |
        # Get network info first (needed for both create and update)
        VPC_ID=$(aws ec2 describe-subnets --query 'Subnets[0].VpcId' --output text)
        SUBNETS=$(aws ec2 describe-subnets --filters "Name=vpc-id,Values=$VPC_ID" --query 'Subnets[*].SubnetId' --output json)
        echo "VPC: $VPC_ID"
        echo "Subnets: $SUBNETS"
        
        if [ "$SUBNETS" = "[]" ] || [ -z "$SUBNETS" ]; then
          echo "ERROR: No subnets available!"
          exit 1
        fi
        
        # Get or create API security group (ALWAYS, even for updates)
        API_SG_ID=$(aws ec2 describe-security-groups \
          --filters "Name=group-name,Values=servermonitoring-api-sg" "Name=vpc-id,Values=$VPC_ID" \
          --query 'SecurityGroups[0].GroupId' \
          --output text 2>/dev/null)
        
        if [ "$API_SG_ID" = "None" ] || [ -z "$API_SG_ID" ]; then
          echo "Creating API security group..."
          API_SG_ID=$(aws ec2 create-security-group \
            --group-name servermonitoring-api-sg \
            --description "Security group for Server Monitoring API" \
            --vpc-id $VPC_ID \
            --query 'GroupId' \
            --output text)
          sleep 2
        else
          echo "Using existing API security group: $API_SG_ID"
        fi
        
        # Ensure security group rules exist (idempotent - won't fail if already exists)
        echo "Ensuring API security group rules..."
        aws ec2 authorize-security-group-egress \
          --group-id $API_SG_ID \
          --ip-permissions IpProtocol=-1,IpRanges='[{CidrIp=0.0.0.0/0}]' 2>/dev/null || echo "Egress rule exists"
        
        aws ec2 authorize-security-group-ingress \
          --group-id $API_SG_ID \
          --protocol tcp \
          --port 8080 \
          --cidr 0.0.0.0/0 2>/dev/null || echo "API ingress rule exists"
        
        VPC_CIDR=$(aws ec2 describe-vpcs --vpc-ids $VPC_ID --query 'Vpcs[0].CidrBlock' --output text)
        aws ec2 authorize-security-group-ingress \
          --group-id $API_SG_ID \
          --protocol tcp \
          --port 443 \
          --cidr $VPC_CIDR 2>/dev/null || echo "HTTPS ingress exists"
        
        echo "‚úÖ API security group rules configured"
        
        # Set SG_ID for VPC endpoints (must be set BEFORE creating endpoints!)
        SG_ID=$API_SG_ID
        echo "üîí Security Group for VPC endpoints: $SG_ID"
        
        # CRITICAL: Ensure Web -> API connectivity rule exists (even on updates!)
        echo "‚ö° Ensuring Web -> API connectivity..."
        WEB_SG_ID=$(aws ec2 describe-security-groups \
          --filters "Name=group-name,Values=servermonitoring-web-sg" "Name=vpc-id,Values=$VPC_ID" \
          --query 'SecurityGroups[0].GroupId' \
          --output text 2>/dev/null)
        
        if [ "$WEB_SG_ID" != "None" ] && [ -n "$WEB_SG_ID" ]; then
          echo "Found Web SG: $WEB_SG_ID - Adding Web -> API rule..."
          aws ec2 authorize-security-group-ingress \
            --group-id $API_SG_ID \
            --protocol tcp \
            --port 8080 \
            --source-group $WEB_SG_ID 2>/dev/null || echo "   Rule already exists (OK)"
          echo "‚úÖ Web -> API connectivity ensured"
        else
          echo "‚ÑπÔ∏è  Web SG doesn't exist yet (will be created later)"
        fi
        
        # ALWAYS create VPC Endpoints FIRST (needed for image pulls regardless of service state)
        echo "üîß Ensuring VPC endpoints for ECR access..."
        
        # Check if subnets have internet gateway routes
        SUBNET_ID=$(echo $SUBNETS | jq -r '.[0]')
        ROUTE_TABLE=$(aws ec2 describe-route-tables \
          --filters "Name=association.subnet-id,Values=$SUBNET_ID" \
          --query 'RouteTables[0].RouteTableId' \
          --output text 2>/dev/null || \
          aws ec2 describe-route-tables \
            --filters "Name=vpc-id,Values=$VPC_ID" "Name=association.main,Values=true" \
            --query 'RouteTables[0].RouteTableId' \
            --output text)
        
        # Create VPC endpoint for ECR API
        aws ec2 create-vpc-endpoint \
          --vpc-id $VPC_ID \
          --vpc-endpoint-type Interface \
          --service-name com.amazonaws.${{ env.AWS_REGION }}.ecr.api \
          --subnet-ids $(echo $SUBNETS | jq -r 'join(" ")') \
          --security-group-ids $SG_ID \
          --private-dns-enabled 2>/dev/null || echo "ECR API endpoint already exists"
        
        # Create VPC endpoint for ECR Docker
        aws ec2 create-vpc-endpoint \
          --vpc-id $VPC_ID \
          --vpc-endpoint-type Interface \
          --service-name com.amazonaws.${{ env.AWS_REGION }}.ecr.dkr \
          --subnet-ids $(echo $SUBNETS | jq -r 'join(" ")') \
          --security-group-ids $SG_ID \
          --private-dns-enabled 2>/dev/null || echo "ECR DKR endpoint already exists"
        
        # Update existing VPC endpoints to ensure they have ALL subnets
        echo "üîß Ensuring VPC endpoints have all subnets..."
        ECR_API_ENDPOINT=$(aws ec2 describe-vpc-endpoints \
          --filters "Name=vpc-id,Values=$VPC_ID" "Name=service-name,Values=com.amazonaws.${{ env.AWS_REGION }}.ecr.api" \
          --query 'VpcEndpoints[0].VpcEndpointId' --output text)
        ECR_DKR_ENDPOINT=$(aws ec2 describe-vpc-endpoints \
          --filters "Name=vpc-id,Values=$VPC_ID" "Name=service-name,Values=com.amazonaws.${{ env.AWS_REGION }}.ecr.dkr" \
          --query 'VpcEndpoints[0].VpcEndpointId' --output text)
        
        if [ "$ECR_API_ENDPOINT" != "None" ] && [ -n "$ECR_API_ENDPOINT" ]; then
          CURRENT_SUBNETS=$(aws ec2 describe-vpc-endpoints --vpc-endpoint-ids $ECR_API_ENDPOINT --query 'VpcEndpoints[0].SubnetIds' --output json)
          ALL_SUBNET_IDS=$(echo $SUBNETS | jq -r '.[]')
          for SUBNET in $ALL_SUBNET_IDS; do
            if ! echo $CURRENT_SUBNETS | grep -q $SUBNET; then
              echo "Adding subnet $SUBNET to ECR API endpoint"
              aws ec2 modify-vpc-endpoint --vpc-endpoint-id $ECR_API_ENDPOINT --add-subnet-ids $SUBNET 2>/dev/null || true
            fi
          done
          echo "‚úÖ ECR API endpoint updated with all subnets"
        fi
        
        if [ "$ECR_DKR_ENDPOINT" != "None" ] && [ -n "$ECR_DKR_ENDPOINT" ]; then
          CURRENT_SUBNETS=$(aws ec2 describe-vpc-endpoints --vpc-endpoint-ids $ECR_DKR_ENDPOINT --query 'VpcEndpoints[0].SubnetIds' --output json)
          ALL_SUBNET_IDS=$(echo $SUBNETS | jq -r '.[]')
          for SUBNET in $ALL_SUBNET_IDS; do
            if ! echo $CURRENT_SUBNETS | grep -q $SUBNET; then
              echo "Adding subnet $SUBNET to ECR DKR endpoint"
              aws ec2 modify-vpc-endpoint --vpc-endpoint-id $ECR_DKR_ENDPOINT --add-subnet-ids $SUBNET 2>/dev/null || true
            fi
          done
          echo "‚úÖ ECR DKR endpoint updated with all subnets"
        fi
        
        # Create VPC endpoint for S3 (needed for ECR layers)
        aws ec2 create-vpc-endpoint \
          --vpc-id $VPC_ID \
          --vpc-endpoint-type Gateway \
          --service-name com.amazonaws.${{ env.AWS_REGION }}.s3 \
          --route-table-ids $ROUTE_TABLE 2>/dev/null || echo "‚úÖ S3 endpoint exists"
        
        # Create VPC endpoint for Secrets Manager
        aws ec2 create-vpc-endpoint \
          --vpc-id $VPC_ID \
          --vpc-endpoint-type Interface \
          --service-name com.amazonaws.${{ env.AWS_REGION }}.secretsmanager \
          --subnet-ids $(echo $SUBNETS | jq -r 'join(" ")') \
          --security-group-ids $SG_ID \
          --private-dns-enabled 2>/dev/null || echo "‚úÖ Secrets Manager endpoint exists"
        
        # Create VPC endpoint for CloudWatch Logs
        aws ec2 create-vpc-endpoint \
          --vpc-id $VPC_ID \
          --vpc-endpoint-type Interface \
          --service-name com.amazonaws.${{ env.AWS_REGION }}.logs \
          --subnet-ids $(echo $SUBNETS | jq -r 'join(" ")') \
          --security-group-ids $SG_ID \
          --private-dns-enabled 2>/dev/null || echo "‚úÖ CloudWatch Logs endpoint exists"
        
        echo "‚úÖ VPC endpoints configured for ECR, S3, Secrets Manager, CloudWatch"
        
        # Check if service exists
        SERVICE_EXISTS=$(aws ecs describe-services --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_API_SERVICE }} --query 'services[0].status' --output text 2>/dev/null || echo "MISSING")
        CREATE_SERVICE="false"
        
        if [ "$SERVICE_EXISTS" = "ACTIVE" ]; then
          echo "Service exists - checking if it has load balancer configuration..."
          
          # Check if service has load balancer configured
          LB_CONFIG=$(aws ecs describe-services --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_API_SERVICE }} --query 'services[0].loadBalancers' --output json)
          
          if [ "$LB_CONFIG" = "[]" ] || [ "$LB_CONFIG" = "null" ]; then
            echo "‚ö†Ô∏è  Service exists WITHOUT load balancer config!"
            echo "üîß Deleting service to recreate with ALB integration..."
            
            # Scale down first
            aws ecs update-service \
              --cluster ${{ env.ECS_CLUSTER }} \
              --service ${{ env.ECS_API_SERVICE }} \
              --desired-count 0
            
            sleep 10
            
            # Force delete
            aws ecs delete-service \
              --cluster ${{ env.ECS_CLUSTER }} \
              --service ${{ env.ECS_API_SERVICE }} \
              --force
            
            echo "Waiting 30 seconds for service deletion..."
            sleep 30
            
            echo "‚úÖ Service deleted - will create new one with ALB"
            CREATE_SERVICE="true"
          else
            echo "Service has load balancer config - updating..."
            aws ecs update-service \
              --cluster ${{ env.ECS_CLUSTER }} \
              --service ${{ env.ECS_API_SERVICE }} \
              --task-definition ${{ steps.api-task-def.outputs.TASK_DEF_ARN }} \
              --force-new-deployment \
              --health-check-grace-period-seconds 300
            
            echo "‚úÖ Service updated successfully!"
            echo "‚è≠Ô∏è  Continuing to Web service deployment..."
            CREATE_SERVICE="false"
          fi
        else
          echo "Service doesn't exist - will create new one"
          CREATE_SERVICE="true"
        fi
        
        if [ "$CREATE_SERVICE" = "true" ]; then
          echo "Creating new API service with ALB integration..."
          
          # Use ALB created in previous step
          echo "Using ALB from previous step..."
          echo "ALB ARN: ${{ env.ALB_ARN }}"
          echo "API Target Group: ${{ env.API_TG_ARN }}"
          echo "API URL: ${{ env.API_URL }}"
          
          # Create service with ALB target group
          aws ecs create-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service-name ${{ env.ECS_API_SERVICE }} \
            --task-definition ${{ steps.api-task-def.outputs.TASK_DEF_ARN }} \
            --desired-count 1 \
            --launch-type FARGATE \
            --health-check-grace-period-seconds 300 \
            --load-balancers "targetGroupArn=${{ env.API_TG_ARN }},containerName=${{ env.API_CONTAINER_NAME }},containerPort=8080" \
            --network-configuration "{
              \"awsvpcConfiguration\": {
                \"subnets\": $SUBNETS,
                \"securityGroups\": [\"$SG_ID\"],
                \"assignPublicIp\": \"ENABLED\"
              }
            }"
          
          echo "‚úÖ API service created with ALB integration"
        else
          echo "‚è© Skipping service creation - service already up-to-date"
        fi


    - name: Check API service created
      run: |
        echo "API service created. Waiting for task to start..."
        sleep 30
        
        # Wait for task to be running
        for i in {1..30}; do
          TASK_COUNT=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_API_SERVICE }} \
            --query 'services[0].runningCount' \
            --output text)
          
          echo "Attempt $i: $TASK_COUNT tasks running"
          
          if [ "$TASK_COUNT" = "1" ]; then
            echo "API task is running!"
            break
          fi
          
          sleep 10
        done
        
        aws ecs describe-services \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.ECS_API_SERVICE }} \
          --query 'services[0].{Status:status,Running:runningCount,Desired:desiredCount}' \
          --output table

    - name: Verify ALB is accessible
      continue-on-error: true
      run: |
        echo "‚è≥ Waiting for ALB to be ready..."
        sleep 20
        
        ALB_DNS=$(aws elbv2 describe-load-balancers \
          --names servermonitoring-alb \
          --query 'LoadBalancers[0].DNSName' \
          --output text)
        
        echo "Quick health check at http://$ALB_DNS/health..."
        
        for i in {1..10}; do
          echo "Health check attempt $i/10..."
          
          if curl -f -s -m 5 "http://$ALB_DNS/health" > /dev/null 2>&1; then
            echo "‚úÖ ALB is healthy!"
            break
          fi
          
          sleep 10
        done
        
        echo "‚ö†Ô∏è  API not yet responding through ALB (this is normal, it takes 2-3 minutes)"
        echo "ALB routing will work once targets are healthy..."

    - name: Create Web task definition with ALB DNS
      run: |
        API_URL="${{ env.API_URL }}"
        echo "Creating web task definition with API_URL=$API_URL (from ALB)"
        
        cat > web-task-definition.json <<EOF
        {
          "family": "servermonitoring-web",
          "networkMode": "awsvpc",
          "requiresCompatibilities": ["FARGATE"],
          "cpu": "256",
          "memory": "512",
          "executionRoleArn": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/ecsTaskExecutionRole-ServerMonitoring",
          "taskRoleArn": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/ecsTaskRole-ServerMonitoring",
          "containerDefinitions": [
            {
              "name": "${{ env.WEB_CONTAINER_NAME }}",
              "image": "${{ env.WEB_IMAGE }}",
              "cpu": 256,
              "memory": 512,
              "essential": true,
              "portMappings": [
                {
                  "containerPort": 80,
                  "protocol": "tcp"
                }
              ],
              "environment": [
                {
                  "name": "API_URL",
                  "value": "$API_URL"
                },
                {
                  "name": "VITE_API_URL",
                  "value": "$API_URL"
                }
              ],
              "logConfiguration": {
                "logDriver": "awslogs",
                "options": {
                  "awslogs-create-group": "true",
                  "awslogs-group": "/ecs/servermonitoring-web",
                  "awslogs-region": "${{ env.AWS_REGION }}",
                  "awslogs-stream-prefix": "ecs"
                }
              },
              "healthCheck": {
                "command": ["CMD-SHELL", "curl -f http://localhost:80/ || exit 1"],
                "interval": 30,
                "timeout": 5,
                "retries": 3,
                "startPeriod": 60
              }
            }
          ]
        }
        EOF

    - name: Register Web task definition
      id: web-task-def
      run: |
        TASK_DEF_ARN=$(aws ecs register-task-definition --cli-input-json file://web-task-definition.json --query 'taskDefinition.taskDefinitionArn' --output text)
        echo "TASK_DEF_ARN=$TASK_DEF_ARN" >> $GITHUB_OUTPUT
        echo "‚úÖ Web task definition registered: $TASK_DEF_ARN"

    - name: Setup Web Target Group and ALB Routing
      run: |
        echo "üîß Setting up Web target group and ALB routing..."
        
        # Get VPC ID
        VPC_ID=$(aws ec2 describe-subnets --query 'Subnets[0].VpcId' --output text)
        echo "VPC ID: $VPC_ID"
        
        if [ -z "$VPC_ID" ] || [ "$VPC_ID" = "None" ]; then
          echo "‚ùå Error: Could not get VPC ID"
          exit 1
        fi
        
        # Get ALB ARN from environment
        ALB_ARN="${{ env.ALB_ARN }}"
        echo "ALB ARN: $ALB_ARN"
        
        if [ -z "$ALB_ARN" ]; then
          echo "‚ùå Error: ALB_ARN environment variable is empty"
          echo "This should have been set in the 'Setup Application Load Balancer' step"
          exit 1
        fi
        
        # Get API Target Group ARN from environment
        API_TG_ARN="${{ env.API_TG_ARN }}"
        echo "API Target Group ARN: $API_TG_ARN"
        
        if [ -z "$API_TG_ARN" ]; then
          echo "‚ùå Error: API_TG_ARN environment variable is empty"
          exit 1
        fi
        
        # Create Web target group
        echo "üîç Checking if Web target group exists..."
        WEB_TG_ARN=$(aws elbv2 describe-target-groups \
          --names servermonitoring-web-tg \
          --query 'TargetGroups[0].TargetGroupArn' \
          --output text 2>/dev/null || echo "None")
        
        if [ "$WEB_TG_ARN" = "None" ] || [ -z "$WEB_TG_ARN" ] || [ "$WEB_TG_ARN" = "null" ]; then
          echo "Creating Web target group..."
          WEB_TG_ARN=$(aws elbv2 create-target-group \
            --name servermonitoring-web-tg \
            --protocol HTTP \
            --port 80 \
            --vpc-id $VPC_ID \
            --target-type ip \
            --health-check-enabled \
            --health-check-path / \
            --health-check-interval-seconds 30 \
            --health-check-timeout-seconds 5 \
            --healthy-threshold-count 2 \
            --unhealthy-threshold-count 3 \
            --query 'TargetGroups[0].TargetGroupArn' \
            --output text)
        else
          echo "Using existing Web target group: $WEB_TG_ARN"
        fi
        echo "‚úÖ Web Target Group: $WEB_TG_ARN"
        
        # Get listener
        LISTENER_ARN=$(aws elbv2 describe-listeners \
          --load-balancer-arn $ALB_ARN \
          --query 'Listeners[0].ListenerArn' \
          --output text)
        
        # Modify default action to forward to Web
        echo "Setting Web as default target..."
        aws elbv2 modify-listener \
          --listener-arn $LISTENER_ARN \
          --default-actions Type=forward,TargetGroupArn=$WEB_TG_ARN
        
        # Delete existing rules then recreate (to ensure they point to current target groups)
        API_TG_ARN="${{ env.API_TG_ARN }}"
        echo "Updating /api/* routing rule to current target group..."
        
        # Get existing rules and delete non-default ones
        EXISTING_RULES=$(aws elbv2 describe-rules --listener-arn $LISTENER_ARN --query 'Rules[?Priority!=`default`].RuleArn' --output text 2>/dev/null || echo "")
        for RULE_ARN in $EXISTING_RULES; do
          echo "Deleting old rule: $RULE_ARN"
          aws elbv2 delete-rule --rule-arn $RULE_ARN 2>/dev/null || true
        done
        
        # Create fresh rule with current target group ARN (single path-pattern with multiple values)
        aws elbv2 create-rule \
          --listener-arn $LISTENER_ARN \
          --priority 10 \
          --conditions Field=path-pattern,Values='/api/*','/swagger*','/health','/hangfire*' \
          --actions Type=forward,TargetGroupArn=$API_TG_ARN
        
        echo "‚úÖ Routing rules updated with current target groups"
        
        echo "‚úÖ ALB routing configured: /api/* -> API, / -> Web"
        echo "WEB_TG_ARN=$WEB_TG_ARN" >> $GITHUB_ENV

    - name: Deploy Web to ECS
      run: |
        # Get subnets and VPC (already created from API deployment)
        VPC_ID=$(aws ec2 describe-subnets --query 'Subnets[0].VpcId' --output text)
        SUBNETS=$(aws ec2 describe-subnets --filters "Name=vpc-id,Values=$VPC_ID" --query 'Subnets[*].SubnetId' --output json)
        
        # Get or create Web security group (REUSE existing, don't delete!)
        SG_ID_WEB=$(aws ec2 describe-security-groups \
          --filters "Name=group-name,Values=servermonitoring-web-sg" "Name=vpc-id,Values=$VPC_ID" \
          --query 'SecurityGroups[0].GroupId' \
          --output text 2>/dev/null)
        
        if [ "$SG_ID_WEB" = "None" ] || [ -z "$SG_ID_WEB" ]; then
          echo "Creating new web security group..."
          SG_ID_WEB=$(aws ec2 create-security-group \
            --group-name servermonitoring-web-sg \
            --description "Security group for Server Monitoring Web" \
            --vpc-id $VPC_ID \
            --query 'GroupId' \
            --output text)
          sleep 2
        else
          echo "Using existing Web security group: $SG_ID_WEB"
        fi
        
        echo "Web SG: $SG_ID_WEB"
        
        # Ensure Web security group rules exist (idempotent)
        echo "Ensuring Web security group rules..."
        aws ec2 authorize-security-group-egress \
            --group-id $SG_ID_WEB \
            --ip-permissions IpProtocol=-1,IpRanges='[{CidrIp=0.0.0.0/0}]' 2>/dev/null || echo "Web egress rule exists"
        
        aws ec2 authorize-security-group-ingress \
            --group-id $SG_ID_WEB \
            --protocol tcp \
            --port 80 \
            --cidr 0.0.0.0/0 2>/dev/null || echo "Web port 80 ingress exists"
        
        echo "‚úÖ Web security group rules configured"
        
        # Get ALB SG to allow ALB -> Web traffic
        ALB_SG_ID=$(aws ec2 describe-security-groups \
          --filters "Name=group-name,Values=servermonitoring-alb-sg" "Name=vpc-id,Values=$VPC_ID" \
          --query 'SecurityGroups[0].GroupId' \
          --output text)
        
        # Allow ALB to reach Web
        aws ec2 authorize-security-group-ingress \
          --group-id $SG_ID_WEB \
          --protocol tcp \
          --port 80 \
          --source-group $ALB_SG_ID 2>/dev/null || echo "ALB -> Web rule exists"
        
        # Use Web TG from previous step
        WEB_TG_ARN="${{ env.WEB_TG_ARN }}"
        echo "Using Web Target Group: $WEB_TG_ARN"
        
        # CRITICAL FIX: Allow web tasks to reach API on port 8080
        echo "‚ö° CRITICAL: Allowing web -> API communication on port 8080..."
        API_SG_ID=$(aws ec2 describe-security-groups \
          --filters "Name=group-name,Values=servermonitoring-api-sg" "Name=vpc-id,Values=$VPC_ID" \
          --query 'SecurityGroups[0].GroupId' \
          --output text)
        
        if [ "$API_SG_ID" != "None" ] && [ -n "$API_SG_ID" ]; then
          echo "API Security Group: $API_SG_ID"
          # Allow API to accept connections from Web security group
          aws ec2 authorize-security-group-ingress \
            --group-id $API_SG_ID \
            --protocol tcp \
            --port 8080 \
            --source-group $SG_ID_WEB 2>/dev/null || echo "Web -> API rule already exists"
          echo "‚úÖ API security group now accepts traffic from Web on port 8080"
        else
          echo "‚ö†Ô∏è  WARNING: Could not find API security group"
        fi
        
        # Check if web service exists
        WEB_SERVICE_EXISTS=$(aws ecs describe-services --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_WEB_SERVICE }} --query 'services[0].status' --output text 2>/dev/null || echo "MISSING")
        LB_CONFIG=""
        CREATE_WEB_SERVICE="false"
        
        echo "Web service status: $WEB_SERVICE_EXISTS"
        
        if [ "$WEB_SERVICE_EXISTS" = "ACTIVE" ]; then
          echo "Web service exists - checking if it has load balancer configuration..."
          
          # Check if service has load balancer configured
          LB_CONFIG=$(aws ecs describe-services --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_WEB_SERVICE }} --query 'services[0].loadBalancers' --output json)
          
          if [ "$LB_CONFIG" = "[]" ] || [ "$LB_CONFIG" = "null" ]; then
            echo "‚ö†Ô∏è  Web service exists WITHOUT load balancer config!"
            echo "üîß Deleting service to recreate with ALB integration..."
            
            # Scale down first
            aws ecs update-service \
              --cluster ${{ env.ECS_CLUSTER }} \
              --service ${{ env.ECS_WEB_SERVICE }} \
              --desired-count 0
            
            sleep 10
            
            # Force delete
            aws ecs delete-service \
              --cluster ${{ env.ECS_CLUSTER }} \
              --service ${{ env.ECS_WEB_SERVICE }} \
              --force
            
            echo "Waiting 30 seconds for service deletion..."
            sleep 30
            
            echo "‚úÖ Service deleted - will create new one with ALB"
            CREATE_WEB_SERVICE="true"
          else
            echo "Web service has load balancer config - updating..."
            aws ecs update-service \
              --cluster ${{ env.ECS_CLUSTER }} \
              --service ${{ env.ECS_WEB_SERVICE }} \
              --task-definition ${{ steps.web-task-def.outputs.TASK_DEF_ARN }} \
              --force-new-deployment \
              --health-check-grace-period-seconds 300
            
            echo "‚úÖ Web service updated successfully!"
          fi
        elif [ "$WEB_SERVICE_EXISTS" = "MISSING" ]; then
          echo "Web service does NOT exist - will create new one"
          CREATE_WEB_SERVICE="true"
        fi
        
        # Create web service with ALB if needed
        if [ "$CREATE_WEB_SERVICE" = "true" ]; then
          echo "üöÄ Creating web service with ALB integration..."
          echo "Target Group: $WEB_TG_ARN"
          echo "Security Group: $SG_ID_WEB"
          echo "Subnets: $SUBNETS"
          
          aws ecs create-service \
              --cluster ${{ env.ECS_CLUSTER }} \
              --service-name ${{ env.ECS_WEB_SERVICE }} \
              --task-definition ${{ steps.web-task-def.outputs.TASK_DEF_ARN }} \
              --desired-count 1 \
              --launch-type FARGATE \
              --health-check-grace-period-seconds 300 \
              --load-balancers "targetGroupArn=$WEB_TG_ARN,containerName=${{ env.WEB_CONTAINER_NAME }},containerPort=80" \
              --network-configuration "{
                \"awsvpcConfiguration\": {
                  \"subnets\": $SUBNETS,
                  \"securityGroups\": [\"$SG_ID_WEB\"],
                  \"assignPublicIp\": \"ENABLED\"
                }
              }"
          
          echo "‚úÖ Web service created successfully!"
        else
          echo "‚è© Skipping Web service creation"
        fi

    - name: Ensure security group connectivity (critical fix)
      run: |
        echo "üîß Final check: Ensuring Web -> API connectivity..."
        VPC_ID=$(aws ec2 describe-subnets --query 'Subnets[0].VpcId' --output text)
        
        # Get both security group IDs
        API_SG_ID=$(aws ec2 describe-security-groups \
          --filters "Name=group-name,Values=servermonitoring-api-sg" "Name=vpc-id,Values=$VPC_ID" \
          --query 'SecurityGroups[0].GroupId' \
          --output text)
        
        WEB_SG_ID=$(aws ec2 describe-security-groups \
          --filters "Name=group-name,Values=servermonitoring-web-sg" "Name=vpc-id,Values=$VPC_ID" \
          --query 'SecurityGroups[0].GroupId' \
          --output text)
        
        echo "API SG: $API_SG_ID"
        echo "Web SG: $WEB_SG_ID"
        
        # Ensure Web -> API rule exists
        echo "Adding Web -> API connectivity rule..."
        aws ec2 authorize-security-group-ingress \
          --group-id $API_SG_ID \
          --protocol tcp \
          --port 8080 \
          --source-group $WEB_SG_ID 2>/dev/null && echo "‚úÖ Rule added" || echo "‚úÖ Rule already exists"
        
        # Also ensure API accepts traffic from anywhere (for direct access)
        aws ec2 authorize-security-group-ingress \
          --group-id $API_SG_ID \
          --protocol tcp \
          --port 8080 \
          --cidr 0.0.0.0/0 2>/dev/null && echo "‚úÖ Public access rule added" || echo "‚úÖ Public access rule exists"
        
        echo "üéØ Security group connectivity verified!"

    - name: Check Web service created
      run: |
        echo "Web service created. Checking initial status..."
        sleep 10
        aws ecs describe-services \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.ECS_WEB_SERVICE }} \
          --query 'services[0].{Status:status,Running:runningCount,Desired:desiredCount}' \
          --output table

    - name: Get ALB URL
      run: |
        echo "üîß Getting Application Load Balancer URL..."
        
        ALB_DNS=$(aws elbv2 describe-load-balancers \
          --names servermonitoring-alb \
          --query 'LoadBalancers[0].DNSName' \
          --output text)
        
        echo "========================================="
        echo "üåê APPLICATION URL: http://$ALB_DNS"
        echo "üîß API (via ALB): http://$ALB_DNS/api/v1/servers"
        echo "‚ù§Ô∏è  Health: http://$ALB_DNS/api/v1/health"
        echo "üìä Hangfire: http://$ALB_DNS/hangfire"
        echo "========================================="
        echo ""
        echo "‚úÖ ALL TRAFFIC GOES THROUGH ALB - NO MORE IP CHANGES!"
        echo "Login at: http://$ALB_DNS/login"
        echo "Credentials: admin / Admin123!"
        echo "========================================="
        
        # Export for next step
        echo "ALB_DNS=$ALB_DNS" >> $GITHUB_ENV
    
    - name: Update deployment URLs file
      run: |
        cat > CURRENT_DEPLOYMENT.md <<EOF
        # üöÄ Current Deployment - Production Ready with ALB
        
        **Last Updated:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')  
        **Commit:** ${{ github.sha }}
        
        ---
        
        ## üåê Application URL (STABLE - Never Changes!)
        
        ### **Main Application**
        **URL:** http://${{ env.ALB_DNS }}
        
        - üè† Dashboard: http://${{ env.ALB_DNS }}/
        - üîê Login: http://${{ env.ALB_DNS }}/login
        - üìä Hangfire: http://${{ env.ALB_DNS }}/hangfire
        
        **Test Credentials:**
        - Admin: \`admin\` / \`Admin@123\`
        - User: \`user\` / \`User@123\`
        
        ---
        
        ### API Endpoints
        **Base URL:** http://${{ env.ALB_DNS }}
        
        - üìñ Swagger UI: http://${{ env.ALB_DNS }}/swagger
        - ‚ù§Ô∏è  Health Check: http://${{ env.ALB_DNS }}/health
        - üîå API v1: http://${{ env.ALB_DNS }}/api/v1/
        
        ---
        
        ## ‚úÖ Production Benefits
        
        ### Application Load Balancer (ALB)
        - ‚úÖ **Stable DNS** - URL never changes across deployments
        - ‚úÖ **High Availability** - Automatic failover
        - ‚úÖ **Health Checks** - Automatic unhealthy target removal
        - ‚úÖ **Zero Downtime** - Rolling deployments
        - ‚úÖ **SSL Ready** - Easy HTTPS certificate attachment
        
        ### Architecture
        ```
        Internet ‚Üí ALB ‚Üí [API Tasks | Web Tasks]
                   ‚Üì
              Path routing:
              /api/* ‚Üí API (port 8080)
              /*     ‚Üí Web (port 80)
        ```
        
        ---
        
        ## üèóÔ∏è Infrastructure Details
        
        - **Cloud Provider:** AWS (us-east-1)
        - **Load Balancer:** Application Load Balancer (ALB)
        - **Orchestration:** ECS Fargate
        - **Container Registry:** Amazon ECR
        - **Deployment:** GitHub Actions CI/CD
        - **Network:** Public subnets with Internet Gateway
        
        ---
        
        ## üîÑ No More IP Hardcoding!
        
        Previous issues with IP changes are **SOLVED**:
        - ‚úÖ Web frontend uses ALB DNS in environment variables
        - ‚úÖ ALB DNS remains constant across all deployments
        - ‚úÖ Task IPs can change freely without breaking anything
        
        **This is production-ready architecture!** üéâ
        
        EOF
        
        git config user.name "GitHub Actions Bot"
        git config user.email "actions@github.com"
        git add CURRENT_DEPLOYMENT.md
        git diff --staged --quiet || git commit -m "Update deployment URLs with ALB [skip ci]"
        git push origin main || echo "No changes to push"

