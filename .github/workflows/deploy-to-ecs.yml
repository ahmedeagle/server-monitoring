name: Deploy to AWS ECS

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  ECR_API_REPOSITORY: servermonitoring-api
  ECS_CLUSTER: servermonitoring-cluster
  ECS_API_SERVICE: servermonitoring-api-service
  API_CONTAINER_NAME: api

jobs:
  deploy:
    name: Deploy to ECS
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1

    - name: Build, tag, and push API image to Amazon ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        docker build -t $ECR_REGISTRY/$ECR_API_REPOSITORY:$IMAGE_TAG -f src/Presentation/ServerMonitoring.API/Dockerfile .
        docker tag $ECR_REGISTRY/$ECR_API_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_API_REPOSITORY:latest
        docker push $ECR_REGISTRY/$ECR_API_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_API_REPOSITORY:latest
        echo "API_IMAGE=$ECR_REGISTRY/$ECR_API_REPOSITORY:$IMAGE_TAG" >> $GITHUB_ENV

    - name: Create API task definition
      run: |
        cat > api-task-definition.json <<EOF
        {
          "family": "servermonitoring-api",
          "networkMode": "awsvpc",
          "requiresCompatibilities": ["FARGATE"],
          "cpu": "512",
          "memory": "1024",
          "executionRoleArn": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/ecsTaskExecutionRole-ServerMonitoring",
          "taskRoleArn": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/ecsTaskRole-ServerMonitoring",
          "containerDefinitions": [
            {
              "name": "${{ env.API_CONTAINER_NAME }}",
              "image": "${{ env.API_IMAGE }}",
              "cpu": 512,
              "memory": 1024,
              "essential": true,
              "portMappings": [
                {
                  "containerPort": 8080,
                  "protocol": "tcp"
                }
              ],
              "environment": [
                {
                  "name": "ASPNETCORE_ENVIRONMENT",
                  "value": "Production"
                },
                {
                  "name": "ASPNETCORE_URLS",
                  "value": "http://+:8080"
                },
                {
                  "name": "UseInMemoryDatabase",
                  "value": "true"
                }
              ],
              "logConfiguration": {
                "logDriver": "awslogs",
                "options": {
                  "awslogs-create-group": "true",
                  "awslogs-group": "/ecs/servermonitoring-api",
                  "awslogs-region": "${{ env.AWS_REGION }}",
                  "awslogs-stream-prefix": "ecs"
                }
              },
              "healthCheck": {
                "command": ["CMD-SHELL", "curl -f http://localhost:8080/health || exit 1"],
                "interval": 30,
                "timeout": 5,
                "retries": 3,
                "startPeriod": 120
              }
            }
          ]
        }
        EOF

    - name: Register API task definition
      id: api-task-def
      run: |
        TASK_DEF_ARN=$(aws ecs register-task-definition --cli-input-json file://api-task-definition.json --query 'taskDefinition.taskDefinitionArn' --output text)
        echo "TASK_DEF_ARN=$TASK_DEF_ARN" >> $GITHUB_OUTPUT

    - name: Deploy to ECS
      run: |
        SERVICE_EXISTS=$(aws ecs describe-services --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_API_SERVICE }} --query 'services[0].status' --output text 2>/dev/null || echo "MISSING")
        
        if [ "$SERVICE_EXISTS" = "ACTIVE" ]; then
          echo "Service exists, deleting and recreating..."
          aws ecs update-service --cluster ${{ env.ECS_CLUSTER }} --service ${{ env.ECS_API_SERVICE }} --desired-count 0
          aws ecs delete-service --cluster ${{ env.ECS_CLUSTER }} --service ${{ env.ECS_API_SERVICE }}
          sleep 10
        fi
        
        echo "Creating service..."
        
        SUBNETS=$(aws ec2 describe-subnets --query 'Subnets[*].SubnetId' --output json)
        echo "Subnets: $SUBNETS"
        
        VPC_ID=$(aws ec2 describe-subnets --query 'Subnets[0].VpcId' --output text)
        echo "VPC: $VPC_ID"
        
        if [ "$SUBNETS" = "[]" ] || [ -z "$SUBNETS" ]; then
          echo "ERROR: No subnets available!"
          exit 1
        fi
        
        # Check if security group exists
        EXISTING_SG=$(aws ec2 describe-security-groups \
          --filters "Name=group-name,Values=servermonitoring-api-sg" \
          --query 'SecurityGroups[0].GroupId' \
          --output text 2>/dev/null || echo "None")
        
        EXISTING_SG_VPC=$(aws ec2 describe-security-groups \
          --filters "Name=group-name,Values=servermonitoring-api-sg" \
          --query 'SecurityGroups[0].VpcId' \
          --output text 2>/dev/null || echo "None")
        
        # Delete if in wrong VPC
        if [ "$EXISTING_SG" != "None" ] && [ "$EXISTING_SG_VPC" != "$VPC_ID" ]; then
          echo "Deleting old security group in wrong VPC..."
          aws ec2 delete-security-group --group-id $EXISTING_SG 2>/dev/null || true
          sleep 5
        fi
        
        # Create security group in correct VPC
        SG_ID=$(aws ec2 create-security-group \
          --group-name servermonitoring-api-sg \
          --description "Security group for Server Monitoring API" \
          --vpc-id $VPC_ID \
          --query 'GroupId' \
          --output text 2>/dev/null || \
          aws ec2 describe-security-groups \
            --filters "Name=group-name,Values=servermonitoring-api-sg" "Name=vpc-id,Values=$VPC_ID" \
            --query 'SecurityGroups[0].GroupId' \
            --output text)
        
        echo "SG: $SG_ID"
          
        aws ec2 authorize-security-group-ingress \
            --group-id $SG_ID \
            --protocol tcp \
            --port 8080 \
            --cidr 0.0.0.0/0 2>/dev/null || true
          
        # Create service with JSON format
        aws ecs create-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service-name ${{ env.ECS_API_SERVICE }} \
            --task-definition ${{ steps.api-task-def.outputs.TASK_DEF_ARN }} \
            --desired-count 1 \
            --launch-type FARGATE \
            --network-configuration "{
              \"awsvpcConfiguration\": {
                \"subnets\": $SUBNETS,
                \"securityGroups\": [\"$SG_ID\"],
                \"assignPublicIp\": \"ENABLED\"
              }
            }"


    - name: Wait for deployment
      run: |
        aws ecs wait services-stable \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.ECS_API_SERVICE }}

    - name: Get service URL
      run: |
        TASK_ARN=$(aws ecs list-tasks --cluster ${{ env.ECS_CLUSTER }} --service-name ${{ env.ECS_API_SERVICE }} --query 'taskArns[0]' --output text)
        
        if [ "$TASK_ARN" = "None" ] || [ -z "$TASK_ARN" ]; then
          echo "No tasks running!"
          exit 1
        fi
        
        ENI_ID=$(aws ecs describe-tasks --cluster ${{ env.ECS_CLUSTER }} --tasks $TASK_ARN --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' --output text)
        PUBLIC_IP=$(aws ec2 describe-network-interfaces --network-interface-ids $ENI_ID --query 'NetworkInterfaces[0].Association.PublicIp' --output text)
        
        echo "========================================="
        echo "API: http://$PUBLIC_IP:8080/swagger"
        echo "Health: http://$PUBLIC_IP:8080/health"
        echo "========================================="

